# JVM问题整理

### **内存区域：能说清jvm的内存划分**

> + **Java堆**：
>   + 存放对象实例；
>   + 垃圾收集器管理的主要区域。
> + **方法区**：
>   + 存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据；
>   + 垃圾收集行为在此区域很少发生；
>   + 运行时常量池也是方法区的一部分；
>
> + **Java 虚拟机栈**：
>
>   + Java 方法执行的内存模型，每个方法执行的过程，就是它所对应的栈帧在虚拟机栈中入栈到出栈的过程；
>   + 服务于 Java 方法；
>   + 可能抛出的异常：
>     - OutOfMemoryError（在虚拟机栈可以动态扩展的情况下，扩展时无法申请到足够的内存）；
>     - StackOverflowError（线程请求的栈深度 > 虚拟机所允许的深度）；
>   + 虚拟机参数设置：`-Xss`。
>
> + **本地方法栈**：
>
>   - 服务于 native 方法；
>   - 可能抛出的异常：与 Java 虚拟机栈一样。
>
> + ### 程序计数器
>
>   - 当前线程所执行的字节码的行号指示器，字节码解释器工作时就是通过改变这个计数器的值来确定下一条要执行的字节码指令的位置
>   - 执行 Java 方法和 native 方法时的区别：
>     - 执行 Java 方法时：记录虚拟机正在执行的字节码指令地址；
>     - 执行 native 方法时：无定义；
>   - 是 5 个区域中唯一不会出现 OOM 的区域。
>
> + **直接内存**：
>   + JDK 1.4 的 NIO 类可以使用 native 函数库直接分配堆外内存；
>   + 不属于虚拟机运行时数据区的一部分。



### **哪些内存需要回收？**

> GC 主要发生在 Java 堆和方法区中。



### 对象是否可回收的判断条件？怎么判断？

> **判断条件**:当然是这个对象再也不会被用到的时候回收。
>
> 
>
> **判断对象是否可用的算法**
>
> 1**引用计数算法**
>
> + 算法描述：
>   + 给对象添加一个引用计数器；
>   + 每有一个地方引用它，计数器加 1；
>   + 引用失效时，计数器减 1；
>   + 计数器值为 0 的对象不再可用。
> + 缺点：
>   + 很难解决循环引用的问题。即 `objA.instance = objB; objB.instance = objA;`，objA 和 objB 都不会再被访问后，它们仍然相互引用着对方，所以它们的引用计数器不为 0，将永远不能被判为不可用。
>
> 2.**可达性分析算法（主流）**
>
> + 算法描述：
>   + 从 "GC Root" 对象作为起点开始向下搜索，走过的路径称为引用链（Reference Chain）；
>   + 从 "GC Root" 开始，不可达的对象被判为不可用。
> + Java 中可作为 “GC Root” 的对象：
>   + 栈中（本地变量表中的reference）
>     + 虚拟机栈中，栈帧中的本地变量表引用的对象；
>     + 本地方法栈中，JNI 引用的对象（native方法）；
>   + 方法区中
>     + 类的静态属性引用的对象；
>     + 常量引用的对象；
>
> 即便如此，一个对象也不是一旦被判为不可达，就立即死去的，宣告一个的死亡需要经过两次标记过程。

### 回收算法

> **基础：标记 - 清除算法**
>
> - 算法描述：
>   - 先标记出所有需要回收的对象（图中深色区域）；
>   - 标记完后，统一回收所有被标记对象（留下狗啃似的可用内存区域……）。
> - 不足：
>   - 效率问题：标记和清理两个过程的效率都不高。
>   - 空间碎片问题：标记清除后会产生大量不连续的内存碎片，导致以后为较大的对象分配内存时找不到足够的连续内存，会提前触发另一次 GC。
>
> 
>
> **解决效率问题：复制算法**
>
> - **算法描述：**
>   - 将可用内存分为大小相等的两块，每次只使用其中一块；
>   - 当一块内存用完时，将这块内存上还存活的对象复制到另一块内存上去，将这一块内存全部清理掉。
> - **不足：** 可用内存缩小为原来的一半，适合GC过后只有少量对象存活的新生代。
> - **节省内存的方法：**
>   - 新生代中的对象 98% 都是朝生夕死的，所以不需要按照 1:1 的比例对内存进行划分；
>   - 把内存划分为：
>     - 1 块比较大的 Eden 区；
>     - 2 块较小的 Survivor 区；
>   - 每次使用 Eden 区和 1 块 Survivor 区；
>   - 回收时，将以上 2 部分区域中的存活对象复制到另一块 Survivor 区中，然后将以上两部分区域清空；
>   - JVM 参数设置：`-XX:SurvivorRatio=8` 表示 `Eden 区大小 / 1 块 Survivor 区大小 = 8`。
>
> 
>
> **解决空间碎片问题：标记 - 整理算法**
>
> - 算法描述：
>   - 标记方法与 “标记 - 清除算法” 一样；
>   - 标记完后，将所有存活对象向一端移动，然后直接清理掉边界以外的内存。
> - **不足：** 存在效率问题，适合老年代。
>
> 
>
> **进化：分代收集算法**
>
> - **新生代：** GC 过后只有少量对象存活 —— **复制算法**
> - **老年代：** GC 过后对象存活率高 —— **标记 - 整理算法**

### GC算法的实现

> + 找到死掉的对象；
>
> + 把它清了。

> **找到死掉的对象**
>
> + **枚举根节点**
>   + 通过OopMap数据结构得知那些地方存在数据引用;
>   + 进行可达性分析时必须确保一致性,即GC进行时必须停顿所有线程;
> + **安全点**
>   + 能停下来开始GC的地方;
>   + 选定条件:是否具有让程序长时间执行的特征;
>     + 例子:方法调用;循环跳转;异常跳转.
>   + 如何让所有线程跑到最近的安全点再停顿下来进行 GC 操作呢？
>     + 抢先式中断
>     + 主动式中断(主要使用)
> + 安全区域
>   + 引用关系不会发生变化的代码片段;
>   + 这个区域的任何地方开始GC都是安全的;



### CMS GC回收分为哪几个阶段？分别做了什么事情？    

> **五个阶段**
>
> + 初始标记
>   + STW，单线程；
>   + 标记以下GC roots能直接关联到的对象，速度很快；
> + 并发标记
>   + 进行GC roots tracing：与应用线程一起运行，是CMS最主要的工作阶段，通过直达对象，扫描全部的对象，进行标记；
> + 重新标记
>   + 为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录；
>   + STW，多线程，时间比初始标记稍长，但远比并发标记短；
>
> - 并发清除：与应用程序一起运行，为何采用清除算法？**CMS主要关注低延迟，因而采用并发方式，清理垃圾时，应用程序还在运行，如何采用压缩算法，则涉及到要移动应用程序的存活对象，此时不停顿，是很难处理的，一般需要停顿下，移动存活对象，再让应用程序继续运行，但这样停顿时间变长，延迟变大**，所以CMS采用清除算法。
>   - 自己的一点思考：标记 - 整理 会将所有存活对象向一端移动，然后直接清理掉边界以外的内存。这就意味着需要一个指针来维护这个分隔存活对象和无用空间的点，而我们知道 CMS 是并发清理的，虽然我们启动了多个线程进行垃圾回收，不过如果使用 标记 - 整理 算法，为了保证线程安全，在整理时要对那个分隔指针加锁，保证同一时刻只有一个线程能修改它，**加锁的这一过程相当于将并行的清理过程变成了串行的，也就失去了并行清理的意义了。**

### CMS有哪些重要参数？ 

> **参数设置：**
>
> - `-XX:+UseCMSCompactAtFullCollection`：在 CMS 要进行 Full GC 时进行内存碎片整理（默认开启）
> - `-XX:CMSFullGCsBeforeCompaction`：在多少次 Full GC 后进行一次空间整理（默认是 0，即每一次 Full GC 后都进行一次空间整理）

### Concurrent Model Failure和ParNew promotion failed什么情况下会发生？ 

>    **并发模式失败（Concurrent Model Failure）**
>
>    并发GC，吞吐量下降，采用标记清除，碎片多，占用额外内存，不能在堆空间满时清理，触发GC：
>    清理时，应用程序还在运行此时如果预留的空间不够应用程序申请的空间的话，则会触发Concurrent Mode Fail，此时便会启用后备收集器：SerialOld进行GC，产生全局停顿。
>
>    CMS收集器无法处理浮动垃圾（Floating Garbage），可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。
>
>    > （1）如果对象提升到年老代的速度太快，而CMS收集器不能保持足够多的可用空间时，就会导致年老代的运行空间不足；
>    > （2）当年老代的碎片化达到某种程度，使得没有足够空间容纳从新生代提升上来的对象时，也会发生并发模式失败。
>
>    当发生并发模式失败时，年老代将进行垃圾收集以释放可用空间，同时也会整理压缩以消除碎片，这个操作需要停止所有的java应用线程，并且需要执行相当长时间。
>
>    **过早提升（Premature Promotion）**
>
>    MinorGC过程中，Survivor可能不足以容纳Eden和另外一个Survivor中存活的对象，如果Survivor中的存活对象溢出，多余的对象将被移到年老代。
>
>    在MinorGC过程中，如果年老代满了无法容纳更多的对象，则MinorGC之后，通常会进行FullGC，这将导致遍历整个java堆，这称为提升失败（Promotion Failure）



### CMS的优缺点？   

> **优点**：
>
> + 并发收集；
> + 低停顿；
>
> 缺点:
>
> + 对CPU资源敏感: 会占用一部分CPU资源,导致程序变慢;
> + 无法处理浮动垃圾: 浮动垃圾: 在CMS清理阶段, 用户线程产生的垃圾;
> + 基于标记-清除, 会产生大量空间碎片;



### 什么是永久代（PermGen ）？

> 绝大部分 Java 程序员应该都见过 "java.lang.OutOfMemoryError: PermGen space "这个异常。这里的 “PermGen space”其实指的就是方法区。不过方法区和“PermGen space”又有着本质的区别。前者是 JVM 的规范，而后者则是 JVM 规范的一种实现，并且只有 HotSpot 才有 “PermGen space”，而对于其他类型的虚拟机，如 JRockit（Oracle）、J9（IBM） 并没有“PermGen space”。由于方法区主要存储类的相关信息，所以对于动态生成类的情况比较容易出现永久代的内存溢出。最典型的场景就是，在 jsp 页面比较多的情况，容易出现永久代内存溢出。

### 什么是元空间（Metaspace）？

> 移除永久代的工作从JDK1.7就开始了。JDK1.7中，存储在永久代的部分数据就已经转移到了Java Heap或者是 Native Heap。但永久代仍存在于JDK1.7中，并没完全移除，譬如符号引用(Symbols)转移到了native heap；字面量(interned strings)转移到了java heap；类的静态变量(class statics)转移到了java heap。
>
> 元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：**元空间并不在虚拟机中，而是使用本地内存**。因此，默认情况下，元空间的大小仅受本地内存限制，但可以通过以下参数来指定元空间的大小：
>
> + -XX:MetaspaceSize，初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize时，适当提高该值。
>
> + -XX:MaxMetaspaceSize，最大空间，默认是没有限制的。
>
>   除了上面两个指定大小的选项以外，还有两个与 GC 相关的属性：
>
> + -XX:MinMetaspaceFreeRatio，在GC之后，最小的Metaspace剩余空间容量的百分比，减少为分配空间所导致的垃圾收集
> + -XX:MaxMetaspaceFreeRatio，在GC之后，最大的Metaspace剩余空间容量的百分比，减少为释放空间所导致的垃圾收集
>
> **为什么要做这个转换？**
>
> + 1、字符串存在永久代中，容易出现性能问题和内存溢出。
> + 2、类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。
> + 3、永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。
> + 4、Oracle 可能会将HotSpot 与 JRockit 合二为一。移除 PermGen 可以促进 HotSpot JVM 与 JRockit VM 的融合，因为 JRockit 没有永久代。



### 有做过哪些GC调优？

> 多数导致GC问题的Java应用，都不是因为我们参数设置错误，而是代码问题，需要记住一点：**GC调优是最后要做的工作**。
>
> GC调优的目的可以总结为下面两点：
>
> - 减少对象晋升到老年代的数量
> - 减少FullGC的执行时间。





### 什么是GC roots? 

> 所谓“GC roots”，或者说tracing GC的“根集合”，就是**一组必须活跃的引用**。
> 例如说，这些引用可能包括：
>
> - 所有Java线程当前活跃的栈帧里指向GC堆里的对象的引用；换句话说，当前所有正在被调用的方法的引用类型的参数/局部变量/临时值。
> - VM的一些静态数据结构里指向GC堆里的对象的引用，例如说HotSpot VM里的Universe里有很多这样的引用。
> - JNI handles，包括global handles和local handles
> - （看情况）所有当前被加载的Java类
> - （看情况）Java类的引用类型静态变量
> - （看情况）Java类的运行时常量池里的引用类型常量（String或Class类型）
> - （看情况）String常量池（StringTable）里的引用
>
> 注意，是一组必须活跃的**引用**，不是对象。
>
> Tracing GC的根本思路就是：给定一个集合的引用作为根出发，通过引用关系遍历对象图，能被遍历到的（可到达的）对象就被判定为存活，其余对象（也就是没有被遍历到的）就自然被判定为死亡。
>
> 注意再注意：tracing GC的本质是通过找出所有活对象来把其余空间认定为“无用”，而不是找出所有死掉的对象并回收它们占用的空间。
>
> 
>
> 作者：RednaxelaFX
> 链接：https://www.zhihu.com/question/53613423/answer/135743258
> 来源：知乎
> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。  



### GC分类？

> GC其实准确分类只有两大种：
>
> - Partial GC：并不收集整个GC堆的模式
>
> - - Young GC：只收集young gen的GC
>   - Old GC：只收集old gen的GC。只有CMS的concurrent collection是这个模式
>   - Mixed GC：收集整个young gen以及部分old gen的GC。只有G1有这个模式
>
> - Full GC：收集整个堆，包括young gen、old gen、perm gen（如果存在的话）等所有部分的模式。
>
> 
>
> 作者：RednaxelaFX
> 链接：https://www.zhihu.com/question/41922036/answer/93079526
> 来源：知乎
> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。





### 为什么要划分成年轻代和老年代？  

>  对传统的、基本的GC实现来说，由于它们在GC的整个工作过程中都要“stop-the-world”，如果能想办法缩短GC一次工作的时间长度就是件重要的事情。
>
> 如果说收集整个GC堆耗时太长，那不如只收集其中的一部分？
> 于是就有好几种不同的划分（partition）GC堆的方式来实现部分收集，而分代式GC就是这其中的一个思路。
>
> 这个思路所基于的基本假设大家都很熟悉了：weak generational hypothesis——大部分对象的生命期很短（die young），而没有die young的对象则很可能会存活很长时间（live long）。
>
> 这是对过往的很多应用行为分析之后得出的一个假设。基于这个假设，如果让新创建的对象都在young gen里创建，然后频繁收集young gen，则大部分垃圾都能在young GC中被收集掉。由于young gen的大小配置通常只占整个GC堆的较小部分，而且较高的对象死亡率（或者说较低的对象存活率）让它非常适合使用copying算法来收集，这样就不但能降低单次GC的时间长度，还可以提高GC的工作效率。
>
> 
>
> 作者：RednaxelaFX
> 链接：https://www.zhihu.com/question/53613423/answer/135743258
> 来源：知乎
> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



### 年轻代为什么被划分成eden、survivor区域？    

> > 由于young gen的大小配置通常只占整个GC堆的较小部分，而且较高的对象死亡率（或者说较低的对象存活率）让它非常适合使用copying算法来收集，这样就不但能降低单次GC的时间长度，还可以提高GC的工作效率。
>
> 
>
> **解决效率问题：复制算法**(相对标记-清除算法)
>
> - **算法描述：**
>   - 将可用内存分为大小相等的两块，每次只使用其中一块；
>   - 当一块内存用完时，将这块内存上还存活的对象复制到另一块内存上去，将这一块内存全部清理掉。
> - **不足：** 可用内存缩小为原来的一半，适合GC过后只有少量对象存活的新生代。
> - **节省内存的方法：**
>   - 新生代中的对象 98% 都是朝生夕死的，所以不需要按照 1:1 的比例对内存进行划分；
>   - 把内存划分为：
>     - 1 块比较大的 Eden 区；
>     - 2 块较小的 Survivor 区；
>   - 每次使用 Eden 区和 1 块 Survivor 区；
>   - 回收时，将以上 2 部分区域中的存活对象复制到另一块 Survivor 区中，然后将以上两部分区域清空；
>   - JVM 参数设置：`-XX:SurvivorRatio=8` 表示 `Eden 区大小 / 1 块 Survivor 区大小 = 8`。

### 年轻代为什么采用的是复制算法？    

> 由于young gen的大小配置通常只占整个GC堆的较小部分，而且较高的对象死亡率（或者说较低的对象存活率）让它非常适合使用copying算法来收集，这样就不但能降低单次GC的时间长度，还可以提高GC的工作效率。

### 老年代为什么采用的是标记清除、标记整理算法    

> 为何采用清除算法？
>
> **CMS主要关注低延迟，因而采用并发方式，清理垃圾时，应用程序还在运行，如何采用压缩算法，则涉及到要移动应用程序的存活对象，此时不停顿，是很难处理的，一般需要停顿下，移动存活对象，再让应用程序继续运行，但这样停顿时间变长，延迟变大**，所以CMS采用清除算法。

### 什么情况下使用堆外内存？要注意些什么？    

> 和堆内内存相对应，堆外内存就是把内存对象分配在Java虚拟机堆以外的内存，这些内存直接受操作系统管理（而不是虚拟机），这样做的结果就是能够在一定程度上减少垃圾回收对应用程序造成的影响。
>
> Java中分配堆外内存的方式有两种
>
> + 通过`ByteBuffer.java#allocateDirect`得到以一个DirectByteBuffer对象
> + 直接调用`Unsafe.java#allocateMemory`分配内存，但Unsafe只能在JDK的代码中调用，一般不会直接使用该方法分配内存。
>
> **堆外内存的使用场景**
>
> + 适合长期存在或能复用的场景
>   + 堆外内存分配回收也是有开销的，所以适合长期存在的对象
>
> + 适合注重稳定的场景
>   + 堆外内存能有效避免因GC导致的暂停问题。
>
> + 适合简单对象的存储
>   + 因为堆外内存只能存储字节数组，所以对于复杂的DTO对象，每次存储/读取都需要序列化/反序列化，
>
> + 适合注重IO效率的场景
>   + 使用堆内内存进行文件、网络的IO时，JVM会使用堆外内存做一次额外的中转，也就是会多一次内存拷贝。
>   + 用堆外内存读写文件性能更好。

### 堆外内存如何被回收？    

> Java的堆外内存回收设计是这样的：当GC发现DirectByteBuffer对象变成垃圾时，会调用`Cleaner#clean`回收对应的堆外内存，一定程度上防止了内存泄露。当然，也可以手动的调用该方法，对堆外内存进行提前回收。

## 类加载系统

### 双亲委派模型：

> 如上图所示的类加载器之间的这种层次关系，就称为类加载器的双亲委派模型（Parent Delegation Model）。该模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。子类加载器和父类加载器不是以继承（Inheritance）的关系来实现，而是通过组合（Composition）关系来复用父加载器的代码。
>
> 双亲委派模型的工作过程为：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的加载器都是如此，因此所有的类加载请求都会传给顶层的启动类加载器，只有当父加载器反馈自己无法完成该加载请求（该加载器的搜索范围中没有找到对应的类）时，子加载器才会尝试自己去加载。
>
> **好处**
>
> 使用这种模型来组织类加载器之间的关系的好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如java.lang.Object类，无论哪个类加载器去加载该类，最终都是由启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。否则的话，如果不使用该模型的话，如果用户自定义一个java.lang.Object类且存放在classpath中，那么系统中将会出现多个Object类，应用程序也会变得很混乱。如果我们自定义一个rt.jar中已有类的同名Java类，会发现JVM可以正常编译，但该类永远无法被加载运行。
>
> **rt.jar包中的java.lang.ClassLoader类**
>
> ```java
> protected synchronized Class loadClass(String name, boolean resolve)  
>         throws ClassNotFoundException {  
>     // 首先检查该name指定的class是否有被加载  
>     Class c = findLoadedClass(name);  
>     if (c == null) {  
>         try {  
>             if (parent != null) {  
>                 // 如果parent不为null，则调用parent的loadClass进行加载  
>                 c = parent.loadClass(name, false);  
>             } else {  
>                 // parent为null，则调用BootstrapClassLoader进行加载  
>                 c = findBootstrapClass0(name);  
>             }  
>         } catch (ClassNotFoundException e) {  
>             // 如果仍然无法加载成功，则调用自身的findClass进行加载  
>             c = findClass(name);  
>         }  
>     }  
>     if (resolve) {  
>         resolveClass(c);  
>     }  
>     return c;  
> }  
> 
> ```
>
> 双亲委派模型是通过loadClass()方法来实现的，根据代码以及代码中的注释可以很清楚地了解整个过程其实非常简单：先检查是否已经被加载过，如果没有则调用父加载器的loadClass()方法，如果父加载器为空则默认使用启动类加载器作为父加载器。如果父类加载器加载失败，则先抛出ClassNotFoundException，然后再调用自己的findClass()方法进行加载。
>
> **ClassLoader 隔离问题**：
>
> 大家觉得一个运行程序中有没有可能同时存在两个包名和类名完全一致的类？ JVM 及 Dalvik 对类唯一的识别是 ClassLoader id + PackageName + ClassName，所以一个运行程序中是有可能存在两个包名和类名完全一致的类的。并且如果这两个”类”不是由一个 ClassLoader 加载，是无法将一个类的示例强转为另外一个类的，这就是 ClassLoader 隔离。
>
> **能不能自己写个类叫java.lang.System？**
>
> 答案：通常不可以，但可以采取另类方法达到这个需求。 解释：为了不让我们写System类，类加载采用委托机制，这样可以保证爸爸们优先，爸爸们能找到的类，儿子就没有机会加载。而System类是Bootstrap加载器加载的，就算自己重写，也总是使用Java系统提供的System，自己写的System类根本没有机会得到加载。
>
> 但是，我们可以自己定义一个类加载器来达到这个目的，为了避免双亲委托机制，这个类加载器也必须是特殊的。由于系统自带的三个类加载器都加载特定目录下的类，如果我们自己的类加载器放在一个特殊的目录，那么系统的加载器就无法加载，也就是最终还是由我们自己的加载器加载。
>
> **“一次编译到处运行”**
>
> Java号称是一门“一次编译到处运行”的语言，但是我们对这句话的理解深度又有多少呢？从我们写的java文件到通过编译器编译成java字节码文件（也就是.class文件），这个过程是java编译过程；而我们的java虚拟机执行的就是字节码文件。不论该字节码文件来自何方，由哪种编译器编译，甚至是手写字节码文件，只要符合java虚拟机的规范，那么它就能够执行该字节码文件。



## Java内存模型(JMM)

> Java内存模型定义了多线程之间共享变量的可见性以及如何在需要的时候对共享变量进行同步。

> 当对象和变量存储到计算机的各个内存区域时，必然会面临一些问题，其中最主要的两个问题是：
>
> 1. 共享对象对各个线程的可见性
> 2. 共享对象的竞争现象

### **共享对象可见性**

> **volatile**
>
> volatile 关键字可以保证变量会直接从主存读取，而对变量的更新也会直接写到主存。volatile原理是基于CPU内存屏障指令实现.
>
> 如果一个变量是volatile修饰的，JMM会在写入这个字段之后插进一个Write-Barrier指令，并在读这个字段之前插入一个Read-Barrier指令。这意味着，如果写入一个volatile变量，就可以保证：
>
> 一个线程写入变量a后，任何线程访问该变量都会拿到最新值。
> 在写入变量a之前的写入操作，其更新的数据对于其他线程也是可见的。因为Memory Barrier会刷出cache中的所有先前的写入。

### 竞争现象

> 可以使用java synchronized代码块。synchronized代码块可以保证同一个时刻只能有一个线程进入代码竞争区，synchronized代码块也能保证代码块中所有变量都将会从主存中读，当线程退出代码块时，对所有变量的更新将会flush到主存，不管这些变量是不是volatile类型的。

> **happens-before**
> 从jdk5开始，java使用新的JSR-133内存模型，基于happens-before的概念来阐述操作之间的内存可见性。
>
> 在JMM中，如果一个操作的执行结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系，这个的两个操作既可以在同一个线程，也可以在不同的两个线程中。
>
> 与程序员密切相关的happens-before规则如下：
>
> 程序顺序规则：一个线程中的每个操作，happens-before于该线程中任意的后续操作。
> 监视器锁规则：对一个锁的解锁操作，happens-before于随后对这个锁的加锁操作。
> volatile域规则：对一个volatile域的写操作，happens-before于任意线程后续对这个volatile域的读。
> 传递性规则：如果 A happens-before B，且 B happens-before C，那么A happens-before C。