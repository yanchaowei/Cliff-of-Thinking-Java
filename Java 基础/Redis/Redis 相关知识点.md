# Redis 相关知识点

### 为什么要用 redis/为什么要用缓存

> 因为传统的关系型数据库如Mysql已经不能适用所有的场景了，比如秒杀的库存扣减，APP首页的访问流量高峰等等，都很容易把数据库打崩，所以引入了缓存中间件，目前市面上比较常用的缓存中间件有 **Redis** 和 **Memcached** 不过中和考虑了他们的优缺点，最后选择了Redis。

> **高性能：**
>
> 假如用户第一次访问数据库中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据存在缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！
>
> **高并发：**
>
> 直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。

### 为什么要用redis而不用map做缓存?

> 缓存分为本地缓存和分布式缓存。
>
> 以java为例，使用自带的map或者guava实现的是本地缓存，最主要的特点是轻量以及快速，生命周期随着jvm的销毁而结束，并且在多实例的情况下，每个实例都需要各自保存一份缓存，缓存不具有一致性。
>
> 使用redis或memcached之类的称为分布式缓存，在多实例的情况下，各实例共用一份缓存数据，缓存具有一致性。缺点是需要保持redis或memcached服务的高可用，整个程序架构上较为复杂。
>
> + Redis 可以用几十 G 内存来做缓存，Map 不行，一般 JVM 也就分几个 G 数据就够大了
> + Redis 的缓存可以持久化，Map 是内存对象，程序一重启数据就没了
> + Redis 可以实现分布式的缓存，Map 只能存在创建它的程序里
> + Redis 可以处理每秒百万级的并发，是专业的缓存服务，Map 只是一个普通的对象
> + Redis 缓存有过期机制，Map 本身无此功能
> + Redis 有丰富的 API，Map 就简单太多了

### redis 和 memcached 的区别

> 对于 redis 和 memcached 我总结了下面四点。现在公司一般都是用 redis 来实现缓存，而且 redis 自身也越来越强大了！
>
> 1. **redis支持更丰富的数据类型（支持更复杂的应用场景）**：Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，zset，hash等数据结构的存储。memcache支持简单的数据类型，String。
> 2. **Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而Memecache把数据全部存在内存之中。**
> 3. **集群模式**：memcached没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 redis 目前是原生支持 cluster 模式的。
> 4. **Memcached是多线程，非阻塞IO复用的网络模型；Redis使用单线程的多路 IO 复用模型。**

###  为什么redis 叫做单线程的模型

> 这里结合**多路复用IO**来看。
>
> redis 内部使用文件事件处理器 `file event handler`，这个文件事件处理器是单线程的，所以 redis 才叫做单线程的模型。它采用 IO 多路复用机制同时监听多个 socket，根据 socket 上的事件来选择对应的事件处理器进行处理。
>
> 文件事件处理器的结构包含 4 个部分：
>
> - 多个 socket
> - IO 多路复用程序
> - 文件事件分派器
> - 事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）
>
> 多个 socket 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 socket，会将 socket 产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理。

### I/O多路复用技术（multiplexing）是什么？

> **深入理解Epoll**
>
> `epoll`是linux2.6内核的一个新的系统调用，`epoll`在设计之初，就是为了替代`select, poll`线性复杂度的模型，epoll的时间复杂度为O(1), 也就意味着，`epoll`在高并发场景，随着文件描述符的增长，有良好的可扩展性。

### redis 设置过期时间

> redis 设置过期时间 => 定期删除 => 惰性删除 => redis内存淘汰机制

### redis 持久化机制

> 很多时候我们需要持久化数据也就是将内存中的数据写入到硬盘里面，大部分原因是为了之后重用数据（比如重启机器、机器故障之后恢复数据），或者是为了防止系统故障而将数据备份到一个远程位置。

### **什么是缓存雪崩？**

> 简介：缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。
>
> **解决**
>
> **失效时间随机**
>
> ```java
> setRedis（Key，value，time + Math.random() * 10000）； 
> ```
>
> 如果Redis是集群部署，将热点数据均匀分布在不同的Redis库中也能避免全部失效的问题，不过本渣我在生产环境中操作集群的时候，单个服务都是对应的单个Redis分片，是为了方便数据的管理，但是也同样有了可能会失效这样的弊端，**失效时间随机**是个好策略。 或者**设置热点数据永远不过期**，有更新操作就更新缓存就好了（比如运维更新了首页商品，那你刷下缓存就完事了，不要设置过期时间），电商首页的数据也可以用这个操作，保险。 

> 举例子啦
>
> **举个简单的例子**：如果所有首页的Key失效时间都是12小时，中午12点刷新的，我零点有个秒杀活动大量用户涌入，假设当时每秒 6000 个请求，本来缓存在可以扛住每秒 5000 个请求，但是缓存当时所有的Key都失效了。此时 1 秒 6000 个请求全部落数据库，数据库必然扛不住，它会报一下警，真实情况可能DBA都没反应过来就直接挂了。此时，如果没用什么特别的方案来处理这个故障，DBA 很着急，重启数据库，但是数据库立马又被新的流量给打死了。这就是我理解的缓存雪崩。
>
> ------敖丙

> 万一大量请求打到数据库怎么办？只能靠MySQL硬刚咯，结合**慢查询**理解下MySQL是怎么被压垮的。

### **什么是缓存穿透？**

> 缓存穿透说简单点就是大量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层。举个例子：某个黑客故意制造我们缓存中不存在的 key 发起大量请求，导致大量请求落到数据库。
>
> 那你了解缓存穿透和击穿么，可以说说他们跟雪崩的区别么？ 嗯，了解，我先说一下缓存穿透吧，缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求，我们数据库的 id 都是1开始自增上去的，如发起为id值为 -1 的数据或 id 为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大，严重会击垮数据库。 小点的单机系统，基本上用postman就能搞死，比如我自己买的阿里云服务
>
> + **缓存穿透**我会在接口层增加校验，比如用户鉴权校验，参数做校验，不合法的参数直接代码Return，比如：id 做基础校验，id <=0的直接拦截等。
> + 从缓存取不到的数据，在数据库中也没有取到，这时也可以将对应Key的Value对写为null、位置错误、稍后重试这样的值具体取啥问产品，或者看具体的场景，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。
> + 正常用户是不会在单秒内发起这么多次请求的，那网关层**Nginx**本渣我也记得有配置项，可以让运维大大对单个IP每秒访问次数超出阈值的IP都拉黑。
> + **Redis**还有一个高级用法**布隆过滤器（Bloom Filter）**这个也能很好的防止缓存穿透的发生，他的原理也很简单就是利用高效的数据结构和算法快速判断出你这个Key是否在数据库中存在，不存在你return就好了，存在你就去查了DB刷新KV再return。

### **什么是缓存击穿？**

> 缓存雪崩是因为大面积的缓存失效，打崩了DB，而缓存击穿不同的是**缓存击穿**是指一个Key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个Key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个完好无损的桶上凿开了一个洞。

> **如何解决？**
>
> + **缓存击穿**的话，设置热点数据永远不过期。或者加上互斥锁就能搞定了

```java
public static String getData(String key) throws InterruptedException {
    // 先从redis中查询数据
    String result = getDataByKV(key);
    // 如果redis中不存在，则查询数据库
    if (StringUtils.isBlank(result)) {
        // 获取锁
        if (reenLock.tryLock()) {
            // 去数据库查询
            result = getDataFromDB(key);
            if (StringUtils.isNotBlank(result)) {
                // 将数据放进缓存
                setDataToKV(key, result);
            }
        } else {
            // 若失败，休息一会再尝试拿锁
            Thread.sleep(100L);
        }
    }
    return result;
}
// 单机实例，分布式锁需要lua脚本保证
```

**总结**

>**有哪些解决办法？**
>
>（中华石杉老师在他的视频中提到过，视频地址在最后一个问题中有提到）：
>
>- 事前：**Redis** 高可用，主从+哨兵，**Redis cluster**，避免全盘崩溃。
>- 事中：本地 **ehcache** 缓存 + **Hystrix** 限流+降级，避免** MySQL** 被打死。
>- 事后：**Redis** 持久化 **RDB**+**AOF**，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。

### 那你使用过Redis分布式锁么，它是什么回事？



### 如何保证缓存与数据库的双写一致性？

> **非严格要求**
>
> > 一般情况下我们都是这样使用缓存的：先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。这种方式很明显会存在缓存和数据库的数据不一致的情况。
>
> **严格要求**
>
> > **读请求和写请求串行化**，串到一个**内存队列**里去。
>
> **注**：一般来说，如果允许缓存可以稍微的跟数据库偶尔有不一致的情况，也就是说如果你的系统**不是严格要求** “缓存+数据库” 必须保持一致性的话，最好不要做这个方案，因为它也会导致系统的吞吐量大幅度降低，用比正常情况下多几倍的机器去支撑线上的一个请求。
>
> 
>
> **Cache Aside Pattern**
>
> 最经典的缓存+数据库读写的模式，就是 Cache Aside Pattern。
>
> - 读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。
> - 更新的时候，**先更新数据库，然后再删除缓存**。
>
> 
>
> **为什么是删除缓存，而不是更新缓存？**
>
> + 缓存不单单是数据库中直接取出来的值，**比较复杂的缓存数据计算的场景**；
> + **这个缓存到底或许不会被频繁访问到**；
> + 其实删除缓存，而不是更新缓存，就是一个 lazy 计算的思想，不要每次都重新做复杂的计算，不管它会不会用到，而是让它到需要被使用的时候再重新计算。像 mybatis，hibernate，都有懒加载思想。

### 假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？

> 使用**keys**指令可以扫出指定模式的key列表。

### 追问：如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？

> 这个时候你要回答Redis关键的一个特性：Redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用**scan**指令，**scan**指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。
>
> **不过，增量式迭代命令也不是没有缺点的： 举个例子， 使用 SMEMBERS 命令可以返回集合键当前包含的所有元素， 但是对于 SCAN 这类增量式迭代命令来说， 因为在对键进行增量式迭代的过程中， 键可能会被修改， 所以增量式迭代命令只能对被返回的元素提供有限的保证 。**
>
> 

### 使用过Redis做异步队列么，你是怎么用的？

> 一般使用list结构作为队列，**rpush**生产消息，**lpop**消费消息。当lpop没有消息的时候，要适当sleep一会再重试。

### 追问可不可以不用sleep呢？

> list还有个指令叫**blpop**，在没有消息的时候，它会阻塞住直到消息到来。

### 追问能不能生产一次消费多次呢？

> 使用pub/sub主题订阅者模式，可以实现 1:N 的消息队列。

### 追问 pub/su b有什么缺点？

> 在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如**RocketMQ**等。

### 究极TM追问Redis如何实现延时队列？

> 使用sortedset，拿时间戳作为score，消息内容作为key调用zadd来生产消息，消费者用**zrangebyscore**指令获取N秒之前的数据轮询进行处理。

### Redis是怎么持久化的？服务主从数据怎么交互的？

> RDB做镜像全量持久化，AOF做增量持久化。因为RDB会耗费较长时间，不够实时，在停机的时候会导致大量丢失数据，所以需要AOF来配合使用。在redis实例重启时，会使用RDB持久化文件重新构建内存，再使用AOF重放近期的操作指令来实现完整恢复重启之前的状态。
>
> **这里很好理解，把RDB理解为一整个表全量的数据，AOF理解为每次操作的日志就好了，服务器重启的时候先把表的数据全部搞进去，但是他可能不完整，你再回放一下日志，数据不就完整了嘛。不过Redis本身的机制是 AOF持久化开启且存在AOF文件时，优先加载AOF文件；AOF关闭或者AOF文件不存在时，加载RDB文件；加载AOF/RDB文件城后，Redis启动成功； AOF/RDB文件存在错误时，Redis启动失败并打印错误信息**

### 追问那如果突然机器掉电会怎样？

> 取决于AOF日志sync属性的配置，如果不要求性能，在每条写指令时都sync一下磁盘，就不会丢失数据。但是在高性能的要求下每次都sync是不现实的，一般都使用定时sync，比如1s1次，这个时候最多就会丢失1s的数据。

### *追问RDB的原理是什么？

> 你给出两个词汇就可以了，fork和cow。fork是指redis通过创建子进程来进行RDB操作，cow指的是**copy on write**，子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会逐渐和子进程分离开来。

### *Pipeline有什么好处，为什么要用pipeline？

> 可以将多次IO往返的时间缩减为一次，前提是**pipeline**执行的指令之间没有因果相关性。使用**redis-benchmark**进行压测的时候可以发现影响redis的QPS峰值的一个重要因素是**pipeline**批次指令的数目。

### *Redis的同步机制了解么？

> Redis可以使用主从同步，从从同步。第一次同步时，主节点做一次**bgsave**，并同时将后续修改操作记录到内存buffer，待完成后将RDB文件全量同步到复制节点，复制节点接受完成后将RDB镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。后续的增量数据通过AOF日志同步即可，有点类似数据库的binlog。

### *是否使用过Redis集群，集群的高可用怎么保证，集群的原理是什么？

> **Redis Sentinal** 着眼于高可用，在master宕机时会自动将slave提升为master，继续提供服务。
>
> **Redis Cluster** 着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储。

### Bloom Filter 原理

>  布隆过滤器的原理是，当一个元素被加入集合时，通过K个散列函数将这个元素映射成一个位数组中的K个点，把它们置为1。检索时，我们只要看看这些点是不是都是1就（大约）知道集合中有没有它了：如果这些点有任何一个0，则被检元素一定不在；如果都是1，则被检元素很可能在。这就是布隆过滤器的基本思想。

### Redis 性能为什么这么好？

> 哪里体现性能好？
>
> 查询速度快：官方提供的数据是可以达到100000+的**QPS（每秒内查询次数）**。

> 几个点需要了解：**基于内存，数据结构，单线程，多路复用IO，非阻塞，底层通信协议**