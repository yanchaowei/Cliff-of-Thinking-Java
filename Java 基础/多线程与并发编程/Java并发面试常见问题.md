# Java并发面试常见问题

#### synchronized与ReentrantLock的区别？

>**两者的共同点：**
>
>- 协调多线程对共享对象、变量的访问
>
>- 可重入，同一线程可以多次获得同一个锁
>
>- 都保证了可见性和互斥性
>
>- 是加锁方式同步，而且都是阻塞式的同步，
>
>  也就是说当如果一个线程获得了对象锁，进入了同步块，其他访问该同步块的线程都必须阻塞在同步块外面等待
>
>**不同点**：
>
>+ `ReentrantLock`是`API`级别的，`synchronized`是`JVM`级别的；
>+ 相比Synchronized，ReentrantLock类提供了一些高级功能，主要有以下3项：
>  + 1.等待可中断。持有锁的线程长期不释放的时候，正在等待的线程可以选择放弃等待，这相当于Synchronized来说可以避免出现死锁的情况。
>  +  2.可实现公平锁。多个线程等待同一个锁时，必须按照申请锁的时间顺序获得锁，Synchronized锁非公平锁，ReentrantLock默认的构造函数是创建的非公平锁，可以通过参数true设为公平锁，但公平锁表现的性能不是很好。
>  +  3.锁绑定多个条件。`ReentrantLock`通过`Condition`可以绑定多个条件
>
>+ 锁的细粒度和灵活度：很明显ReenTrantLock优于Synchronized。
>+ ReenTrantLock的实现是一种自旋锁，通过循环调用CAS操作来实现加锁。它的性能比较好也是因为避免了使线程进入内核态的阻塞状态。**想尽办法避免线程进入内核的阻塞状态是我们去分析和理解锁设计的关键钥匙**。
>
>**使用时如何选择**？
>
>仅当`synchronized`不能满足时才使用`ReentrantLock`，因为使用`ReentrantLock`要非常小心，不释放锁将影响其他需要该锁的代码块运行
> 不能使用`synchronized`不满足的情形：
>
>- 公平性
>- 可中断
>- 分块结构的加锁，比如`jdk1.7ConcurrentHashMap`的分段锁。（？）

#### 乐观锁和悲观锁的区别？ 

> **悲观锁**：
>
> 总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（**共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程**）。
>
> 传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中`synchronized`和`ReentrantLock`等独占锁就是悲观锁思想的实现。
>
> **乐观锁**：
>
> 总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据。
>
> 
>
> **两种锁的使用场景**
>
> 各有优缺点
>
> + **乐观锁适用于写比较少的情况下（多读场景）**，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。
> + 如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以**一般多写的场景下用悲观锁就比较合适。**
>
> 



#### 如何实现一个乐观锁？    

> **乐观锁常见的两种实现方式**
>
> + 版本号机制
>
> 一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。
>
> +  CAS算法，即compare and swap（比较与交换）
>   + 缺点：
>     + ABA 问题；
>     + 循环时间长开销大；
>     + 只能保证一个共享变量的原子操作（jdk 1.5 之前）









#### Java中的锁有哪些？有什么区别？

> ，一般Java锁分为两种，一种是synchronized关键字，它是基于底层CPU指令实现的锁，另外一种是Lock锁，是基于jdk实现的一种锁。
>
> 传统的synchronized是一个重量级锁，缺点是有多个线程获取锁时，获取失败的线程会进入阻塞状态，成功获取锁的线程在处理完逻辑后会通知阻塞态的线程，这时候是随机挑选的属于非公平锁。
>
> 而lock锁，比如ReentrantLock在默认情况下唤醒被阻塞的线程的方式也是属于非公平锁，但是可动态调整锁的方式，当构造参数传为fair=true表示在公平环境下获取锁，言归正传，所有的jdk实现的锁ReentrantLock、CountDownLatch、Semaphore通过内部匿名类继承了AbstractQueuedSynchronizer，然后重写AQS提供的部分方法。



#### 同步队列AQS的实现原理？

> AQS内部维护一个同步队列，所有的同步队列中的线程通过自旋方式不断获取同步状态。当一个线程无法获取同步状态时，通过创建一个Node节点并将此节点加入队列的尾部，此队列严格按照FIFO方式出入队列，只有当前线程是头结点并且成功获取到同步状态，此时的线程就可出队列；

####   

#### AQS是如何唤醒下一个线程的？  

> 调用unparkSuccessor(Node node)唤醒后继节点。
>
> 可能会存在当前线程的后继节点为null，超时、被中断的情况，如果遇到这种情况了，则需要跳过该节点，从尾节点向前查找。
>
> 但是为何是从tail尾节点开始，而不是从node.next开始呢？原因在于node.next仍然可能会存在null或者取消了，所以采用tail回溯办法找第一个可用的线程。最后调用LockSupport的unpark(Thread thread)方法唤醒该线程。



#### ReentrantLock如何实现公平和非公平锁是如何实现？ 

>   ReentrantLock默认的构造函数是创建的非公平锁，可以通过参数true设为公平锁。
>
> 使用CAS方式在acquire()之前先尝试获取锁，在lock的时候，先是尝试将AQS的status从0设为1，成功的话就把当前线程设置为锁的持有者。
>
> 如果尝试失败了，和公平锁一样，基于模板方法，调用tryAcquire()尝试直接去获取资源，只是在获取资源的过程中，公平锁先判断同步队列中是否有节点在等待，没有节点等待才尝试修改status，而非公平锁这里不会去判断队列中是否为空，直接尝试修改。



#### CountDownLatch和CyclicBarrier的区别？各自适用于什么场景？ 

> **CountDownLatch**:
>
> + 减计数方式;
> + 计算为0时释放所有等待的线程;
> + 计数为0时，无法重置;
> + 调用countDown()方法计数减一，调用await()方法只进行阻塞，对计数没任何影响;
> + 不可重复利用。
>
> CyclicBarrier：
>
> + 加计数方式；
> + 计数达到指定值时释放所有等待线程；
> + 计数达到指定值时，计数置为0重新开始；
> + 调用await()方法计数加1，若加1后的值不等于构造方法的值，则线程阻塞；
> + 可重复利用。
>
> **使用场景**：
>
> + CountDownLatch是一个同步的辅助类，允许一个或多个线程，等待其他一组线程完成操作，再继续执行。
> + 我们在玩LOL英雄联盟时会出现十个人不同加载状态，但是最后一个人由于各种原因始终加载不了100%，于是游戏系统自动等待所有玩家的状态都准备好，才展现游戏画面。
>
> + CyclicBarrier是一个同步的辅助类，允许一组线程相互之间等待，达到一个共同点，再继续执行。
> + CD：司机在等人坐满了才开车，阻塞主体是外部线程。 CB：人在等其他人来了再上车，阻塞主体是多个线程。



#### 适用ThreadLocal时要注意什么？比如说内存泄漏?   

> **内存泄漏**
>
> > **内存泄漏**指由于疏忽或错误造成程序未能释放已经不再使用的[内存](https://zh.wikipedia.org/wiki/内存)。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致在释放该段内存之前就失去了对该段内存的控制，从而造成了内存的浪费。
>
> > **弱引用**与[强引用](https://zh.wikipedia.org/w/index.php?title=强引用&action=edit&redlink=1)相对，是指不能确保其引用的[对象](https://zh.wikipedia.org/wiki/对象_(计算机科学))不会被[垃圾回收器](https://zh.wikipedia.org/wiki/垃圾回收器)回收的引用。一个对象若只被弱引用所引用，则被认为是[不可访问](https://zh.wikipedia.org/wiki/不可访问内存)（或弱可访问）的，并因此可能在任何时刻被回收。
> >
> > Java是第一个将[强引用](https://zh.wikipedia.org/w/index.php?title=强引用&action=edit&redlink=1)作为默认对象引用的主流语言。如果创建了一个弱引用，然后在代码的其它地方用 `get()`获得真实对象，由于弱引用无法阻止垃圾回收，`get()`随时有可能开始返回`null`（假如对象没有被强引用）。
>
> 在 ThreadLocalMap 的 set()，get() 和 remove() 方法中，都有清除无效 Entry 的操作，这样做是为了降低内存泄漏发生的可能。
>
> Entry 中的 key 使用了弱引用的方式，这样做是为了降低内存泄漏发生的概率，但不能完全避免内存泄漏。
>
> 好的，下面可以分析以下。
>
> 假设 Entry 的 key 没有使用弱引用的方式，而是使用了强引用：由于 ThreadLocalMap 的生命周期和当前线程一样长，那么当引用 ThreadLocal 的对象被回收后，由于 ThreadLocalMap 还持有 ThreadLocal 和对应 value 的强引用，ThreadLocal 和对应的 value 是不会被回收的，这就导致了内存泄漏。所以 Entry 以弱引用的方式避免了 ThreadLocal 没有被回收而导致的内存泄漏，但是此时 value 仍然是无法回收的，依然会导致内存泄漏。
>
> ThreadLocalMap 已经考虑到这种情况，并且有一些防护措施：在调用 ThreadLocal 的 get()，set() 和 remove() 的时候都会清除当前线程 ThreadLocalMap 中所有 key 为 null 的 value。这样可以降低内存泄漏发生的概率。所以我们在使用 ThreadLocal 的时候，每次用完 ThreadLocal 都调用 remove() 方法，清除数据，防止内存泄漏。
>
> 



#### 说一说往线程池里提交一个任务会发生什么？    

> 按照如下顺序来处理：
>
> - 1、如果线程池中的线程数量少于corePoolSize，即使线程池中有空闲线程，也会创建一个新的线程来执行新添加的任务；
> - 2、如果线程池中的线程数量大于等于corePoolSize，但缓冲队列workQueue未满，则将新添加的任务放到workQueue中，按照FIFO的原则依次等待执行（线程池中有线程空闲出来后依次将缓冲队列中的任务交付给空闲的线程执行）；
> - 3、如果线程池中的线程数量大于等于corePoolSize，且缓冲队列workQueue已满，但线程池中的线程数量小于maximumPoolSize，则会创建新的线程来处理被添加的任务；
> - 4、如果线程池中的线程数量等于了maximumPoolSize，有4种才处理方式（该构造方法调用了含有5个参数的构造方法，并将最后一个构造方法为RejectedExecutionHandler类型，它在处理线程溢出时有4种方式，这里不再细说，要了解的，自己可以阅读下源码）。
> - 总结起来，也即是说，当有新的任务要处理时，先看线程池中的线程数量是否大于corePoolSize，再看缓冲队列workQueue是否满，最后看线程池中的线程数量是否大于maximumPoolSize。
> - 另外，当线程池中的线程数量大于corePoolSize时，如果里面有线程的空闲时间超过了keepAliveTime，就将其移除线程池，这样，可以动态地调整线程池中线程的数量。
>
> 
>
> + 默认情况下，创建完线程池后并不会立即创建线程, 而是等到有任务提交时才会创建线程来进行处理。（除非调用prestartCoreThread或prestartAllCoreThreads方法） 
> + 当线程数小于核心线程数时，每提交一个任务就创建一个线程来执行，即使当前有线程处于空闲状态，直到当前线程数达到核心线程数。  
> + 当前线程数达到核心线程数时，如果这个时候还提交任务，这些任务会被放到队列里，等到线程处理完了手头的任务后，会来队列中取任务处理。  
> + 当前线程数达到核心线程数并且队列也满了，如果这个时候还提交任务，则会继续创建线程来处理，直到线程数达到最大线程数。
> + 当前线程数达到最大线程数并且队列也满了，如果这个时候还提交任务，则会触发饱和策略。 
> + 如果某个线程的控线时间超过了keepAliveTime，那么将被标记为可回收的，并且当前线程池的当前大小超过了核心线程数时，这个线程将被终止。

#### 线程池的几个参数如何设置？    

> - corePoolSize：线程池中所保存的核心线程数，包括空闲线程。
> - maximumPoolSize：池中允许的最大线程数。
> - keepAliveTime：线程池中的空闲线程所能持续的最长时间。
> - unit：持续时间的单位。
> - workQueue：任务执行前保存任务的队列，仅保存由execute方法提交的Runnable任务。

#### 线程池的非核心线程什么时候会被释放？    

> 1. `Worker`类中由一个大循环，判断条件是`task != null || (task = getTask()) != null`，task自然就是我们要执行的任务了，当task空而且getTask（）取不到任务的时候，这个while()就会结束，循环体里面进行的就是task.run();
> 2. 这里我们就可以猜想，肯定是这个循环一直没有退出，所以才能维持着这一个线程不断运行，当有外部任务进来的时候，循环体就能getTask()并且执行。
> 3. 下面最后放getTask()里面的代码，验证猜想:
>   1. 真相大白了，里面进行的也是一个死循环，主要看 `Runnable r = timed ?
>     workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : workQueue.take();`
>   2. 工作队列workQueue会一直去拿任务，属于核心线程的会一直卡在` workQueue.take()`方法，直到拿到Runnable 然后返回，非核心线程会 `workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS)` ，如果超时还没有拿到，下一次循环判断`compareAndDecrementWorkerCount`就会返回null,Worker对象的run()方法循环体的判断为null,任务结束，然后线程被系统回收。

#### 如何排查死锁？



