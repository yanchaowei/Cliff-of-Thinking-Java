# Java面试题大全

## Java

1. JAVA中的几种基本数据类型是什么，各自占用多少字节。

   > + 4种整形：
   >   + byte：1 字节；(取值-128~127)
   >   + short：2 字节；（取值-32768~32767）
   >   + int：4 字节；
   >   + long：8 字节；
   > + 2种浮点类型：
   >   + float：4 字节
   >   + double：8 字节（3.14F位浮点型，没有F默认为double）
   > + 1种Unicode编码的字符单元的字符型：
   >   + char：2 字节
   > + 1中Boolean类型：
   >   + boolean：1 字节

2. String类能被继承吗，为什么。

   > + String 类是不能被继承的，因为他是被final关键字修饰的。
   >
   > + String类的Immutable（不可变）属性，String类实际是一个char[]数组存储数据的。而这个数组也是被final关键字修饰的。
   >
   > **什么样的类不能被继承？**
   >
   > + 在Java中，只要是被定义为final的类，也可以说是被final修饰的类，就是不能被继承的。
   > + final是java中的一个关键字，可以用来修饰变量、方法和类。用关键词final修饰的域成为最终域。用关键词final修饰的变量一旦赋值，就不能改变，也称为修饰的标识为常量。如果一个类的域被关键字final所修饰，它的取值在程序的整个执行过程中将不会改变。
   > + 假如说整个类都是final，就表明自己不希望从这个类继承，或者不答应其他任何人采取这种操作。换言之，出于这样或那样的原因，我们的类肯定不需要进行任何改变；或者出于安全方面的理由，我们不希望进行子类化（子类处理）。

3. String，Stringbuffer，StringBuilder的区别。

   > **三者之间的区别**：
   >
   > + 都是final类，都不允许被继承；
   >
   > + String类长度是不可变的，StringBuffer和StringBuilder类长度是可以改变的；
   >
   > + StringBuffer类是线程安全的，StringBuilder不是线程安全的；
   >
   > **String 和 StringBuffer：**
   >
   > 1、String类型和StringBuffer类型的主要性能区别：String是不可变的对象，因此每次在对String类进行改变的时候都会生成一个新的string对象，然后将指针指向新的string对象，所以经常要改变字符串长度的话不要使用string，因为每次生成对象都会对系统性能产生影响，特别是当内存中引用的对象多了以后，JVM的GC就会开始工作，性能就会降低；
   >
   > 2、使用StringBuffer类时，每次都会对StringBuffer对象本身进行操作，而不是生成新的对象并改变对象引用，所以多数情况下推荐使用StringBuffer，特别是字符串对象经常要改变的情况；
   >
   > 3、在某些情况下，String对象的字符串拼接其实是被Java Compiler编译成了StringBuffer对象的拼接，所以这些时候String对象的速度并不会比StringBuffer对象慢，
   >
   > **StringBuilder**
   >
   > StringBuilder是5.0新增的，此类提供一个与 StringBuffer 兼容的 API，但不保证同步。该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候（这种情况很普遍）。如果可能，建议优先采用该类，因为在大多数实现中，它比 StringBuffer 要快。两者的方法基本相同
   >
   > **使用策略**
   >
   > 1、基本原则：如果要操作少量的数据，用String ；单线程操作大量数据，用StringBuilder ；多线程操作大量数据，用StringBuffer。
   >
   > 2、不要使用String类的”+”来进行频繁的拼接，因为那样的性能极差的，应该使用StringBuffer或StringBuilder类，这在Java的优化上是一条比较重要的原则，

4. ArrayList和LinkedList有什么区别。

   >   1. ArrayList是实现了基于动态数组的数据结构，而LinkedList是基于链表的数据结构；
   >   2. 对于随机访问get和set，ArrayList要优于LinkedList，因为LinkedList要移动指针；
   >   3. 对于添加和删除操作add和remove，一般大家都会说LinkedList要比ArrayList快，因为ArrayList要移动数据。但是实际情况并非这样，对于添加或删除，LinkedList和ArrayList并不能明确说明谁快谁慢，下面会详细分析。

5. 讲讲类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，当new的时候，他们的执行顺序。

   > https://blog.csdn.net/Vencc__/article/details/52222628

6. 用过哪些Map类，都有什么区别，HashMap是线程安全的吗,并发下使用的Map是什么，他们内部原理分别是什么，比如存储方式，hashcode，扩容，默认容量等。

   > **存储原理**：
   >
   > JDK1.8 HashMap底层是数组和链表结合在一起使用也就是链表散列。HashMap通过key的hashCode来计算hash值，当hashCode相同时，通过“拉链法”解决冲突。当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。
   >
   > **索引位置计算方式**
   >
   > ```java
   > (table.length - 1) & hash
   > ```
   >
   > **扩容**
   >
   > 旧容量的两倍
   >
   > **默认容量**
   >
   > 采用了**延迟初始化操作**，也就是table只有在用到的时候才初始化，如果你不对他进行`put`等操作的话，table的长度永远为"零"，put操作后，初始化容量为16。

7. HashTable 和 HashMap 的区别？

   > **注**：这里是jdk1.7，jdk 1.8改了
   >
   > **HashTable** ： HashTable和HashMap的实现原理几乎一样，差别无非是
   >
   > + **1.HashTable不允许key和value为null；
   > + 2.HashTable是线程安全的。
   >
   > **但是HashTable线程安全的策略实现代价却太大了，简单粗暴，get/put所有相关操作都是synchronized的，这相当于给整个哈希表加了一把**大锁**，多线程访问时候，只要有一个线程访问或操作该对象，那其他线程只能阻塞，相当于将所有的操作**串行化**，在竞争激烈的并发场景中性能就会非常差。

8. 有了Hashtable为啥需要ConCurrentHashMap？

   > jdk 1.8
   >
   > - Hashtable是在**每个方法上都加上了Synchronized**完成同步，效率低下。
   > - ConcurrentHashMap通过在**部分加锁**和**利用CAS算法**来实现同步。
   >
   > **ConcurrentHashMap的核心要点：**
   >
   > - **底层结构是散列表(数组+链表)+红黑树**，这一点和HashMap是一样的。
   > - Hashtable是将所有的方法进行同步，效率低下。而ConcurrentHashMap作为一个高并发的容器，它是通过**部分锁定+CAS算法来进行实现线程安全的**。CAS算法也可以认为是**乐观锁**的一种~
   > - 在高并发环境下，统计数据(计算size...等等)其实是无意义的，因为在下一时刻size值就变化了。
   > - get方法是非阻塞，无锁的。重写Node类，通过volatile修饰next来实现每次获取都是**最新**设置的值
   > - **ConcurrentHashMap的key和Value都不能为null**
   >
   > **对比JDK1.7与1.8**
   >
   > 首先是数据结构上：
   >
   > - 1.7是segment数组，+Segment（类似HashMap的结构）
   > - 1.8是数据+链表/红黑树与HashMap类似
   >
   > 并发上：
   >
   > - 1.7是使用ReentrantLock锁住每个Segment
   > - 1.8是使用CAS+synchronized
   >
   > 为什么超过8要使用红黑树
   >
   > - 首先链表的结构存储要比红黑树存储节省空间
   > - 而链表在查询上又没有红黑树块
   > - 这个时候就需要一个边界，源码作者做了一个泊松分布运算，在链表达到8时的概率已经非常小了。而链表长度为8时，查找费时也不大。概率只有千万分之几

9. hashmap如何解决hash冲突，为什么hashmap中的链表需要转成红黑树？    

   > 当 HashMap 中有大量的元素都存放到同一个桶中时，这个桶下有一条长长的链表，这个时候 HashMap 就相当于一个单链表，假如单链表有 n 个元素，遍历的时间复杂度就是 O(n)，如果 hash 冲突严重，由这里产生的性能问题尤为突显。
   > JDK 1.8 中引入了红黑树，当链表长度 >= TREEIFY_THRESHOLD（8） & tab.length >= MIN_TREEIFY_CAPACITY（64）时，链表就会转化为红黑树，它的查找时间复杂度为 O(logn)，以此来优化这个问题。

10. 为何HashMap的数组长度一定是2的次幂？

    > **两个函数保证了他的长度为2的n次方**
    >
    > - tableSizeFor()
    >
    >   - 当构建函数时，threshold的初始值和 `tableSizeFor()`这个函数有关。我们再进入`tableSizeFor`，这个是返回一个比输入值大的或者等于的最小的 2的n次方。
    >   - 推荐文章：[Java8 HashMap之tableSizeFor](https://www.cnblogs.com/loading4/p/6239441.html)
    >
    > - resize()
    >
    >   - ```java
    >     newCap = oldCap << 1	// 新容量是旧容量的2倍
    >     ```
    >
    > **2的n次有什么好处**
    >
    > - HashMap的下标计算公式：index = HashCode（Key） & （Length - 1），如果数组长度不是2的次幂，那么 Length 的二进制有的位置上面一定会出现 0，则按位与 & 进行过运算之后，不同的hash值碰撞的概率更大，也就是说有些index结果的出现几率会更大，而有些index结果永远不会出现。
    > - 扩容后，节点重 hash 为什么只可能分布在 “原索引位置” 与 “原索引 + oldCap 位置”；计算方便。
    > - 原因：因为下标位置计算为：hash & （Length - 1），老表容量扩容到原来的2倍后，二进制表示（length - 1）上就是左边高位多一个1，此时再与hash值进行 & 运算，取决于hash值的高一位是否为1，若为0，则与原来位置一样，没有影响，若为1，则恰好比原来位置大一个旧容量的大小。
    >
    > 源码中他们采用了**延迟初始化操作**，也就是table只有在用到的时候才初始化，如果你不对他进行`put`等操作的话，table的长度永远为"零"。
    >
    > - **分布均匀**：如果不是2的n次方，那么有些位置上是永远不会被用到；
    >   - table长度如果不是2的幂，则`table.length`的二进制有些位上会出现0，在计算index（=HashCode（Key） & （Length - 1）)时，就会出现有些index结果的出现几率会更大，而有些index结果永远不会出现。
    > - **方便计算**，扩容后计算新位置，非常方便
    >   - 当容量一定是2^n时，h & (length - 1) == h % length；
    > - **计算索引需要**
    >   - `hash&(newTable.length-1)` ==  `hash&(oldTable.length-1)+hash&oldTable.length`
    >   - 因为table的长度一定是2的n次方，也就是oldCap 一定是2的n次方，也就是说 oldCap有且只有一位是1，而且这个位置在最高位；所以`hash&oldTable.length==oldTable.length`
    >   - 扩容代码中，使用 e 节点的 hash 值跟 oldCap 进行位与运算，以此决定将节点分布到 “原索引位置” 或者 “原索引 + oldCap 位置” 上。
    >
    > **tableSizeFor的功能**（不考虑大于最大容量的情况）
    >
    > - 返回**大于输入参数且最近的2的整数次幂的数**。
    >
    > - ```
    >   static final int tableSizeFor(int cap) {
    >       int n = cap - 1;
    >       n |= n >>> 1;
    >       n |= n >>> 2;
    >       n |= n >>> 4;
    >       n |= n >>> 8;
    >       n |= n >>> 16;
    >       return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
    >   }
    >   ```
    >
    > 

11. hashmap什么时候会触发扩容？

    > 当向容器添加元素的时候，会判断当前容器的元素个数，如果大于等于阈值—即当前数组的长度乘以加载因子的值的时候，就要自动扩容啦。

12. jdk1.8之前并发操作hashmap时为什么会有死循环的问题？

    > 在JDK1.7之前才会出现的问题，简单来说就是在高并发下，在内部操作时导致链表死循环引用。
    >
    > ```java
    > void transfer(Entry[] newTable, boolean rehash) {
    >  int newCapacity = newTable.length;
    >  for (Entry<K,V> e : table) {
    >      while(null != e) {
    >          Entry<K,V> next = e.next;
    >          if (rehash) {
    >              e.hash = null == e.key ? 0 : hash(e.key);
    >          }
    >          int i = indexFor(e.hash, newCapacity);
    >          e.next = newTable[i];
    >          newTable[i] = e; 	// 每次都将节点放在链表头，导致最终链表顺序和原链表顺序相反
    >          e = next;
    >      }
    >  }
    > }
    > ```
    >
    > 在JDK1.8后，这个问题得到了优化：
    >
    > ```java
    > for (int j = 0; j < oldCap; ++j) {
    >  Node<K,V> e;
    >  if ((e = oldTab[j]) != null) {
    >      oldTab[j] = null;
    >      if (e.next == null)
    >          newTab[e.hash & (newCap - 1)] = e;
    >      else if (e instanceof TreeNode)
    >          ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);
    >      else { // preserve order
    >          Node<K,V> loHead = null, loTail = null;		// 1、
    >          Node<K,V> hiHead = null, hiTail = null;
    >          Node<K,V> next;
    >          do {
    >              next = e.next;
    >              if ((e.hash & oldCap) == 0) {
    >                  if (loTail == null)
    >                      loHead = e;
    >                  else
    >                      loTail.next = e;				// 2、
    >                  loTail = e;
    >              }
    >              else {
    >                  if (hiTail == null)
    >                      hiHead = e;
    >                  else
    >                      hiTail.next = e;				// 2、
    >                  hiTail = e;
    >              }
    >          } while ((e = next) != null);
    >          if (loTail != null) {
    >              loTail.next = null;
    >              newTab[j] = loHead;						// 3、
    >          }
    >          if (hiTail != null) {
    >              hiTail.next = null;
    >              newTab[j + oldCap] = hiHead;
    >          }
    >      }
    >  }
    > }
    > 
    > ```
    >
    > 

13. JAVA8的ConcurrentHashMap为什么放弃了分段锁，有什么问题吗，如果你来设计，你如何设计。

    > **为什么不用ReentrantLock而用synchronized ?**
    >
    > - 减少内存开销:如果使用ReentrantLock则需要节点继承AQS来获得同步支持，增加内存开销，而1.8中只有头节点需要进行同步。
    > - 内部优化:synchronized则是JVM直接支持的，JVM能够在运行时作出相应的优化措施：锁粗化、锁消除、锁自旋等等。
    >
    > **关于设计，需要并发方面的知识**

14. 如何用LinkedHashMap实现LRU？

    > **LinkedHashMap介绍**
    >
    > 从LinkedHashMap的定义里面可以看到它单独维护了一个双向链表，用于记录元素插入的顺序。这也是为什么我们打印LinkedHashMap的时候可以按照插入顺序打印的支撑。而accessOrder属性则指明了进行遍历时是按照什么顺序进行访问,我们可以通过它的构造方法自己指定顺序。
    >
    > **当accessOrder=true**
    >
    > 在插入的时候LinkedHashMap复写了HashMap的newNode以及newTreeNode方法,并且在方法内部更新了双向链表的指向关系。
    >
    > 同时插入的时候调用了afterNodeAccess()方法以及afterNodeInsertion()方法，在HashMap中这两个方法是空实现，而在LinkedHashMap中则有具体实现,这两个方法也是专门给LinkedHashMap进行回调处理的。
    >
    > afterNodeAccess()方法中如果accessOrder=true时会移动节点到双向链表尾部。当我们在调用map.get()方法的时候如果accessOrder=true也会调用这个方法，这就是为什么访问顺序输出时访问到的元素移动到链表尾部的原因。
    >
    > **afterNodeInsertion(boolean evict)**
    >
    > ```
    > // evict如果为false，则表处于创建模式,当我们new HashMap(Map map)的时候就处于创建模式
    > void afterNodeInsertion(boolean evict) { // possibly remove eldest
    > LinkedHashMap.Entry<K,V> first;
    > 
    > // removeEldestEntry 总是返回false,所以下面的代码不会执行。
    > if (evict && (first = head) != null && removeEldestEntry(first)) {
    >    K key = first.key;
    >    removeNode(hash(key), key, null, false, true);
    > }
    > }
    > 复制代码
    > ```
    >
    > **实现LRU**
    >
    > ```
    > public class LRUCache<K,V> extends LinkedHashMap<K,V> {
    >  
    > private int cacheSize;
    > 
    > public LRUCache(int cacheSize) {
    >    super(16,0.75f,true);
    >    this.cacheSize = cacheSize;
    > }
    > 
    > /**
    >    * 判断元素个数是否超过缓存容量
    >    */
    >   @Override
    >   protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {
    >       return size() > cacheSize;
    >   }
    > }
    > ```

15. 如何用TreeMap实现一致性hash？

    > **普通的 hash 算法**通常都是对机器数量进行取余.
    >
    > 当使用负载均衡的时候，负载均衡器根据对象的 key 对机器进行取余，这个时候，原有的 key 取余现有的机器数 4 就找不到那台机器了！笨一点的办法，就是在增加机器的时候，清除所有缓存，但这会导致缓存击穿甚至缓存雪崩，严重情况下引发 DB 宕机。
    >
    > **一致性hash**
    >
    > 可以假设有一个 2 的 32 次方的环形，缓存节点通过 hash 落在环上。而对象的添加也是使用 hash，但很大的几率是 hash 不到缓存节点的。怎么办呢？**找离他最近的那个节点。** 比如顺时针找前面那个节点。
    >
    > **一致性 hash 有什么问题呢？**
    >
    > 集群环境负载不够均衡。
    >
    > 原因是：如果缓存节点分布不均匀。
    >
    > 怎么办？
    >
    > 可以在不均的地方给他弄均匀。在空闲的地方加入 **虚拟节点**，这些节点的数据映射到真实节点上，就可以了。

16. 有没有有顺序的Map实现类，如果有，他们是怎么保证有序的。

    > **LinkedHashMap **
    >
    > LinkedHashMap 是 HashMap 的一个子类，它保留插入的顺序，如果需要输出的顺序和输入时的相同，那么就选用 LinkedHashMap。
    > LinkedHashMap 实现与 HashMap 的不同之处在于，**LinkedHashMap 维护着一个运行于所有条目的双重链接列表。此链接列表定义了迭代顺序，该迭代顺序可以是插入顺序或者是访问顺序。**
    >
    > 怎么保证有序？ LinkedHashMap 采用的 hash 算法和 HashMap 相同，但是它重新定义了数组中保存的元素 Entry，**该 Entry 除了保存当前对象的引用外，还保存了其上一个元素 before 和下一个元素 after 的引用，从而在哈希表的基础上又构成了双向链接列表**
    >
    > 

17. 抽象类和接口的区别，类可以继承多个类么，接口可以继承多个接口么,类可以实现多个接口么。

    > **抽象类（abstract class）**
    >
    > + 使用abstract修饰符修饰的类。官方点的定义就是：如果一个类没有包含足够多的信息来描述一个具体的对象，这样的类就是抽象类。
    > + 抽象类在实际应用中，更多的是因为类中有抽象方法。抽象方法：只声明，不实现。具体的实现由继承它的子类来实现。
    > + 一个类中含有抽象方法（被abstract修饰），那么这个类必须被声明为抽象类（被abstract修饰）。
    >
    > **接口（interface）：**
    >
    > + 官方定义：接口在java中是一个抽象类型，是抽象方法的集合。一个类通过继承接口的方式，从而继承接口的抽象方法。
    >
    > + 接口是个集合，并不是类。类描述了属性和方法，而接口只包含方法（未实现的方法）。接口和抽象类一样不能被实例化，因为不是类。但是接口可以被实现（使用 implements 关键字）。实现某个接口的类必须在类中实现该接口的全部方法。虽然接口内的方法都是抽象的（和抽象方法很像，没有实现）但是不需要abstract关键字。
    >
    > + 接口中没有构造方式（因为接口不是类）
    >
    > + 接口中的方法必须是抽象的（不能实现）
    >
    > + 接口中除了static、final变量，不能有其他变量
    >
    > + 接口支持多继承（一个类可以实现多个接口）
    >
    > **抽象类和接口的区别**：
    >
    > + 抽象类可以有默认的方法实现完全是抽象的。接口根本不存在方法的实现。
    > + 抽象类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。子类使用关键字implements来实现接口。它需要提供接口中所有声明的方法的实现。
    > + 抽象类可以有构造器，而接口不能有构造器
    > + 抽象方法可以有public、protected和default这些修饰符，接口方法默认修饰符是public。你不可以使用其它修饰符。
    > + 抽象类在java语言中所表示的是一种继承关系，一个子类只能存在一个父类，但是可以存在多个接口。
    > + 抽象方法比接口速度要快，接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法。

18. 继承和聚合的区别在哪。

    > 继承指的是一个类继承另外的一个类的功能，并可以增加它自己的新功能的能力，继承是类与类或者接口与接口之间最常见的关系；在Java中此类关系通过关键字extends明确标识。
    >
    > 聚合指的是聚合体现的是整体与部分、拥有的关系，此时整体与部分之间是可分离的，他们可以具有各自的生命周期；比如计算机与CPU、公司与员工的关系等；

19. IO模型有哪些，讲讲你理解的nio ，他和bio，aio的区别是啥，谈谈reactor模型。

20. 反射的原理，反射创建类实例的三种方式是什么。

    > ### 反射的原理
    >
    > - 得到 class 文件
    >   - 把 java 文件保存到本地硬盘，得到 .java 文件
    >   - 编译 java 文件，得到 .class 文件
    >   - JVM 把 .class 文件加载到内存中，class 文件在内存中使用 Class 类表示
    > - 通过 class 文件得到 Class 类，可以通过以下 3 种方式获得 Class 类
    >   - 通过成员变量获得： `类名.class`
    >   - 通过具体对象获得： `对象.getClass()`
    >   - 通过 Class 的静态方法获取： `Class.forName("classFilePath")`
    > - 通过 Class 类获取 class 文件中的内容，包括：成员变量，构造方法，普通方法，它们都可以用相应的类表示：
    >   - 成员方法：`Field`
    >   - 构造方法：`Constructor`
    >   - 普通方法：`Method`
    >
    > **创建类实例的两种方法**
    >
    > + 通过 Class 对象的 `newInstance()` 方法创建。
    >
    >   ```java
    >   // 调用无参构造器 ，若是没有，则会报异常
    >   Object o = clazz.newInstance();　　
    >   ```
    >
    > + 有带参数的构造函数的类，先获取到其构造对象，再通过该构造方法类获取实例：
    >
    >   ```java
    >   //获取构造函数类的对象
    >   Constroctor constroctor = clazz.getConstructor(String.class,Integer.class); /
    >   // 使用构造器对象的newInstance方法初始化对象
    >   Object obj = constroctor.newInstance("龙哥", 29); 
    >   ```

21. 反射中，Class.forName和ClassLoader区别 。

    > **区别：**
    >
    > + Class.forName除了将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块。
    > + 而classloader只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容，只有在newInstance才会去执行static块。
    >
    > **分析：**
    >
    > ClassLoader就是遵循双亲委派模型最终调用启动类加载器的类加载器，实现的功能是“通过一个类的全限定名来获取描述此类的二进制字节流”，获取到二进制流后放到JVM中。Class.forName()方法实际上也是调用的CLassLoader来实现的。
    >
    > `Class.forName(className)`方法，内部实际调用的方法是  `Class.forName(className,true,classloader);`
    >
    > 第2个boolean参数表示类是否需要初始化， Class.forName(className)默认是需要初始化。
    >
    > 一旦初始化，就会触发目标对象的 static块代码执行，static参数也也会被再次初始化。
    >
    > `ClassLoader.loadClass(className)`方法，内部实际调用的方法是 `ClassLoader.loadClass(className,false);`
    >
    > 第2个 boolean参数，表示目标对象是否进行链接，false表示不进行链接，由上面介绍可以，
    >
    > 不进行链接意味着不进行包括初始化等一些列步骤，那么静态块和静态对象就不会得到执行
    >
    > 

22. 描述动态代理的几种实现方式，分别说出相应的优缺点。

    > **根据字节码的创建时机**来分类，可以分为**静态代理**和**动态代理**：
    >
    > - 所谓**静态**也就是在**程序运行前**就已经存在代理类的**字节码文件**，代理类和真实主题角色的关系在运行前就确定了。
    > - 而动态代理的源码是在程序运行期间由**JVM**根据反射等机制**动态的生成**，所以在运行前并不存在代理类的字节码文件
    >
    > **静态代理的缺点**
    >
    > 虽然静态代理实现简单，且不侵入原代码，但是，当场景稍微复杂一些的时候，静态代理的缺点也会暴露出来。
    >
    > 1、 当需要代理多个类的时候，由于代理对象要实现与目标对象一致的接口，有两种方式：
    >
    > - 只维护一个代理类，由这个代理类实现多个接口，但是这样就导致**代理类过于庞大**
    > - 新建多个代理类，每个目标对象对应一个代理类，但是这样会**产生过多的代理类**
    >
    > 2、 当接口需要增加、删除、修改方法的时候，目标对象与代理类都要同时修改，**不易维护**
    >
    >
    > 
    >
    > **Java中两种常见的动态代理方式：JDK原生动态代理和CGLIB动态代理。**
    >
    > **JDK 动态代理**：
    >
    > - 为了解决静态代理中，生成大量的代理类造成的冗余；
    > - JDK 动态代理只需要实现 InvocationHandler 接口，重写 invoke 方法便可以完成代理的实现，
    > - jdk的代理是利用反射生成代理类 Proxyxx.class 代理类字节码，并生成对象
    > - jdk动态代理之所以**只能代理接口**是因为**代理类本身已经extends了Proxy，而java是不允许多重继承的**，但是允许实现多个接口
    > - **优点**：解决了静态代理中冗余的代理实现类问题。
    > - **缺点**：JDK 动态代理是基于接口设计实现的，如果没有接口，会抛异常。
    >
    > **CGLIB 代理**：
    >
    > - 由于 JDK 动态代理限制了只能基于接口设计，而对于没有接口的情况，JDK方式解决不了；
    > - CGLib 采用了非常底层的字节码技术，其原理是通过字节码技术为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑，来完成动态代理的实现。
    > - 实现方式实现 MethodInterceptor 接口，重写 intercept 方法，通过 Enhancer 类的回调方法来实现。
    > - 但是CGLib在创建代理对象时所花费的时间却比JDK多得多，所以对于单例的对象，因为无需频繁创建对象，用CGLib合适，反之，使用JDK方式要更为合适一些。
    > - 同时，由于CGLib由于是采用动态创建子类的方法，对于final方法，无法进行代理。
    > - **优点**：没有接口也能实现动态代理，而且采用字节码增强技术，性能也不错。
    > - **缺点**：技术实现相对难理解些。
    >
    > > 参考：https://juejin.im/post/5c1ca8df6fb9a049b347f55c

23. 动态代理与cglib实现的区别。

    > **JDK 动态代理**
    >
    > JDK 动态代理只需要实现 InvocationHandler 接口，重写 invoke 方法便可以完成代理的实现，
    >
    > jdk的代理是利用反射生成代理类 Proxyxx.class 代理类字节码，并生成对象
    >
    > jdk动态代理之所以**只能代理接口**是因为**代理类本身已经extends了Proxy，而java是不允许多重继承的**，但是允许实现多个接口。
    >
    > **CGLib **
    >
    > CGLib 采用了非常底层的字节码技术，其原理是通过字节码技术为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑，来完成动态代理的实现。
    >
    > 实现方式实现 MethodInterceptor 接口，重写 intercept 方法，通过 Enhancer 类的回调方法来实现。
    >
    > > 链接：https://juejin.im/post/5c1ca8df6fb9a049b347f55c

24. 为什么CGlib方式可以对接口实现代理。

    > 创建代理类的工厂 该类要实现 MethodInterceptor 接口。
    >
    > 该类中完成三样工作： 
    >
    > + 声明目标类的成员变量，并创建以目标类对象为参数的构造器。用于接收目标对象
    > + 定义代理的生成方法，用于创建代理对象。方法名是任意的。代理对象即目标类的子类 
    > + 定义回调接口方法。对目标类的增强这在这里完成

25. final的用途。

    > **final是一个关键字，在Java中表示为一个修饰符（Modifier）**
    >
    > **使用（类和方法）**
    >
    > 一个`.java`文件在被编译器编译后得到了一个对应的`.class`文件，这个是一个二进制流文件，我们在类中定义的方法此时都被翻译成了字节码信息保存了起来，而方法的信息对应常量池入口地址都存在在一个`method_info`表中，同时这里也包含了access_flags，也就是编译器如何对**final**修饰的内容进行检查。
    >
    > 在`cp_info constant pool`和`method_info`包含了一个类中方法所有的信息，而这些信息便组成了一个**符号引用**，也是就说一个符号引用只是描述了一个方法的信息，而不是一个方法在实际运行时内存中的实际的入口地址（**直接引用**），那么也就说有一些方法需要在运行时才能知道目标方法的直接引用。
    >
    > 在一个class的解析阶段，JVM会完成一个任务，将那些不需要在执行阶段才知道直接引用的方法（如多态性）解析出来，即将常量池中的符号引用转换为直接引用。换句话说，我们要调用的目标方法在编译器编译的时期若可以确定好是谁，就直接进行解析，而不是动态的等待哪个方法。
    >
    > 在JVM中，方法被调用的instruction（指令）一共有5条：
    >
    > > 1. invokestatic ：调用静态方法
    > > 2. invokespecial ：调用私有方法、构造器方法、父类方法
    > > 3. invokevirtual ：调用虚方法
    > > 4. invokeinterface ：调用接口方法
    > > 5. invokedynamic ：先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法
    >
    > 在上面的给出的5条指令中，JVM利用`invokevirtual`指令调用虚方法，但是这里面有一个特殊的就是**final**修饰的方法，虽然调用**final**修饰的方法也是利用`invokevirtual`调用的，但是由于**final**修饰的方法无法被覆盖，所以也就无须对方法接受进行多态选择。那么final方法就和`invokestatic`调用的静态方法、`invokespecial`调用的私有方法等一并在解析阶段将符号引用解析为直接引用，所生成的直接引用将包含一个指向实际操作码的指针。
    >
    > 回到了**内联（inline）**的分析上，明确一点，内联是发生在编译期的一个优化操作，所做的优化操作的意义在于两个字，**“替换”** ，是一种利用**空间置换时间**的一个策略。
    >
    > 方法内联调用都完成了简化，这种简化是体现在方法的简化，这样做的好处显而易见，**消除了更多方法的调用**，较少方法的调用就意味在虚拟机栈中消耗的资源更少（如不会创建新的StackFrame栈帧），所有的调用都是由内联方法自己发起，自己完成弹栈压栈操作、恢复寄存器（恢复执行上下文）等。其实，朝着简单的方向理解，内联就是在执行***copy+replace\***的动作。
    >
    > **小结如下:**
    >
    > + final修饰类，更多从设计（Design）的角度去考虑吧，一个被**final**修饰的类无法子类化，即不能被继承。
    > + final修饰类，类中的方法默认都是**final** 修饰的。
    > + final修饰方法，如果从设计（Design）的角度去考虑，如果类之间体现了继承关系，那么**final** 修饰的方法则不能被子类重写或覆盖。如果没有体现继承关系，就从效率的角度考虑吧，但是**请切记：对于Java虚拟机来说编译器在编译期间会自动进行内联优化，这是由编译器决定的，对于我们开发人员来说，我们一定要设计好break-even的平衡，不要滥用final。**
    >
    > **使用（域）**
    >
    > **final**能修饰的域，2种类型。
    >
    > 1. 基本数据类型
    >
    >    + 程序编译期间的常量，它永远不会变。
    >    + 在运行期间为一个**final**修饰的域初始化一个值，不希望它会发生变化。
    >
    >    在编译后得到的`.class`文件中，有这么一块内容，叫常量池。常量池一定要包含常量！没错，那么一个类中被**final**修饰的域在这个时候就会被放入这个大池子中。原因很简单，为了**效率**。 其实将一个基本数据类型修饰为**final**的目的最单纯最美好，就是希望它不要变。这样系统有就可以做一些优化操作，将这些常量值装在需要计算的过程中，让它们充当类似于宏的身份，换句话说，编译器可以在编译期间提前完成一些计算工作，省去了在运行时对于变量的相对复杂的操作。这里要补充的一点就是一个编译期间的类文件中，常量池中的基本数据类型的常量是不知道具体的值是什么，换句话说，在文件编译过后，虽然知道一个域是常量，但是至于这个常量的具体内容是什么，此时是无从知晓的。
    >
    >    只有当运行时，常量才会真正的被赋值，对于`static`和没有`static`修饰的基本数据类型来说，是有差异的，差异就在于`static`修饰的域是在类载入的时候进行初始化的，所有实例共享同一个常量，同时Java虚拟机没有把它当作类变量，在使用它的任何类的常量池或者字节码流中直接存放的是它表示的常量值。
    >
    > 2. 引用类型
    >
    >    如果有**final**修饰一个引用类型变量，不是说明这个引用类型指向的实际地址的对象不可变，而是说这个引用不能再指向其他地址的对象，而对象本身是可以改变的。
    >
    > **使用（内部类）**
    >
    > 描述：
    >
    > 在一个方法中创建了一个内部类的实例，内部类中的方法使用到该方法的方法参数。
    >
    > 问题来了，内部类的方法并没有执行啊！ 但是方法结束后该方法的栈帧已经被虚拟机栈弹出了，如果按照我们的想象，该方法参数还没用就没有了，这就不好了！
    > 显然JVM不会这么做，在临释放该方法参数之前，就将这个参数变量做了一次备份操作。当我们在创建内部类对象的时候，方法参数就会被存入实例中一个相同名称的变量中，编译器必须检测对局部变量的访问，为每一个变量建立对应的数据域，并将局部变量拷贝到构造器中，以便**将这些数据域初始化为局部变量的副本**。
    >
    > 那么我们将方法参数列表中的变量修饰为final的，防止了这个变量在方法中被修改，因此就做到了局部变量与在内部类建立的拷贝副本保持了一致。
    >
    > **总结**：
    >
    > 1. final可以修饰类，方法，域。
    > 2. final的使用很简单，合理且精确的使用final需要些经验和原理支撑。
    > 3. final要从设计角度和效率角度综合考虑，对于方法和类来说，切勿滥用final。
    > 4. final修饰域这是很有效的做法，可以适当减轻系统计算的负担。
    > 5. final还有一部分内容涉及到并发，可能是我没有涉及到的。
    > 6. final和private可以使用，编译器不会报错，但是没有什么意义。
    > 7. final不能和abstract一起使用，因为语义是冲突的，很好理解。
    >
    > > 参考：https://juejin.im/entry/58c4811161ff4b005d94fed2

26. 写出三种单例模式实现 。

    > **定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点。**
    >
    > 1. **恶汉模式**
    >
    >    ```java
    >    public class Singleton {  
    >        private static Singleton instance = new Singleton();  
    >        private Singleton (){
    >        }
    >        public static Singleton getInstance() {  
    >            return instance;  
    >        }  
    >    }  
    >    ```
    >
    >    在类加载时就完成了初始化，所以类加载较慢，但获取对象的速度快。 这种方式基于类加载机制避免了多线程的同步问题，但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化instance显然没有达到懒加载的效果。
    >
    > 2. 懒汉模式（线程不安全）
    >
    >    ```java
    >    public class Singleton {  
    >        private static Singleton instance;  
    >        private Singleton (){
    >        }   
    >        public static Singleton getInstance() {  
    >            if (instance == null) {  
    >                instance = new Singleton();  
    >            }  
    >            return instance;  
    >        }  
    >    }  
    >    ```
    >
    >    懒汉模式申明了一个静态对象，在用户第一次调用时初始化，虽然节约了资源，但第一次加载时需要实例化，反映稍慢一些，而且在多线程不能正常工作。
    >
    > 3. 懒汉模式（线程不安全）
    >
    >    ```java
    >    public class Singleton {  
    >        private static Singleton instance;  
    >        private Singleton (){
    >        }
    >        public static synchronized Singleton getInstance() {  
    >            if (instance == null) {  
    >                instance = new Singleton();  
    >            }  
    >            return instance;  
    >        }  
    >    }  
    >    ```
    >
    >    这种写法能够在多线程中很好的工作，但是每次调用getInstance方法时都需要进行同步，造成不必要的同步开销，而且大部分时候我们是用不到同步的，所以不建议用这种模式。
    >
    > 4. 懒汉模式（双重检查）
    >
    >    ```java
    >    public class Singleton {  
    >        private volatile static Singleton instance;  
    >        private Singleton (){
    >        }   
    >        public static Singleton getInstance() {  
    >            if (instance== null) {  
    >                synchronized (Singleton.class) {  
    >                    if (instance== null) {  
    >                        instance= new Singleton();  
    >                    }  
    >                }  
    >            }  
    >            return singleton;  
    >        }  
    >    }  
    >    ```
    >
    >    这种写法在getSingleton方法中对singleton进行了两次判空，第一次是为了不必要的同步，第二次是在singleton等于null的情况下才创建实例。在这里用到了volatile关键字，双重检查模式是正确使用volatile关键字的场景之一。
    >    在这里使用volatile会或多或少的影响性能，但考虑到程序的正确性，牺牲这点性能还是值得的。 DCL优点是资源利用率高，第一次执行getInstance时单例对象才被实例化，效率高。缺点是第一次加载时反应稍慢一些，在高并发环境下也有一定的缺陷，虽然发生的概率很小。DCL虽然在一定程度解决了资源的消耗和多余的同步，线程安全等问题，但是他还是在某些情况会出现失效的问题，也就是DCL失效，在《java并发编程实践》一书建议用静态内部类单例模式来替代DCL。
    >
    > 5. **静态内部类单例模式**
    >
    >    ```java
    >    public class Singleton { 
    >        private Singleton(){
    >        }
    >        public static Singleton getInstance(){  
    >            return SingletonHolder.sInstance;  
    >        }  
    >        private static class SingletonHolder {  
    >            private static final Singleton sInstance = new Singleton();  
    >        }  
    >    } 
    >    ```
    >
    >    第一次加载Singleton类时并不会初始化sInstance，只有第一次调用getInstance方法时虚拟机加载SingletonHolder 并初始化sInstance ，这样不仅能确保线程安全也能保证Singleton类的唯一性，所以推荐使用静态内部类单例模式。
    >
    > > 参考：https://blog.csdn.net/itachi85/article/details/50510124

27. 如何在父类中为子类自动完成所有的hashcode和equals实现？这么做有何优劣。

    > >  参考：https://www.iteye.com/blog/java-min-1416727

28. 请结合OO设计理念，谈谈访问修饰符public、private、protected、default在应用设计中的作用。

29. 深拷贝和浅拷贝区别。

    > **深拷贝与浅拷贝的区别**
    >
    > 深拷贝和浅拷贝是只针对Object和Array这样的引用数据类型的。
    >
    > 浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。
    >
    > **浅拷贝与赋值的区别**
    >
    > 当我们把一个对象赋值给一个新的变量时，**赋的其实是该对象的在栈中的地址，而不是堆中的数据**。也就是两个对象指向的是同一个存储空间，无论哪个对象发生改变，其实都是改变的存储空间的内容，因此，两个对象是联动的。
    >
    > 浅拷贝是按位拷贝对象，**它会创建一个新对象**，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址 ，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。即默认拷贝构造函数只是对对象进行浅拷贝复制(逐个成员依次拷贝)，即只复制对象空间而不复制资源。
    >
    > > 参考：https://juejin.im/post/5b5dcf8351882519790c9a2e

30. 数组和链表数据结构描述，各自的时间复杂度。

    > **数组**
    >
    > + 在内存中，数组是一块连续的区域。
    > + 数组需要预留空间，在使用前要先申请占内存的大小，可能会浪费内存空间。 
    > + 插入数据和删除数据效率低，插入数据时，这个位置后面的数据在内存中都要向后移。删除数据时，这个数据后面的数据都要往前移动。 
    > + 随机读取效率很高。因为数组是连续的，知道每一个数据的内存地址，可以直接找到给地址的数据。
    > + 并且不利于扩展，数组定义的空间不够时要重新定义数组。
    > + **优点**
    >   + 随机访问性强
    >   + 查找速度快
    > + **缺点**
    >   + 插入和删除效率低
    >   + 可能浪费内存
    >   + 内存空间要求高，必须有足够的连续内存空间。
    >   + 数组大小固定，不能动态拓展
    >
    > **链表**
    >
    > + 在内存中可以存在任何地方，不要求连续。
    > + 每一个数据都保存了下一个数据的内存地址，通过这个地址找到下一个数据。
    > + 增加数据和删除数据很容易。
    > + 查找数据时效率低，因为不具有随机访问性。
    > + 不指定大小，扩展方便。链表大小不用定义，数据随意增删。
    > + **优点**
    >   + 插入删除速度快
    >   + 内存利用率高，不会浪费内存
    >   + 大小没有固定，拓展很灵活。
    > + **缺点**
    >   + 不能随机查找，必须从第一个开始遍历，查找效率低
    >
    > **时间复杂度**
    >
    > | -    | 数组 | 链表 |
    > | ---- | ---- | ---- |
    > | 读取 | O(1) | O(n) |
    > | 插入 | O(n) | O(1) |
    > | 删除 | O(n) | O(1) |

31. error和exception的区别，CheckedException，RuntimeException的区别。

    > **Error 和 Exception**
    >
    > + **Exception（异常）是应用程序中可能的可预测、可恢复问题。**一般大多数异常表示中度到轻度的问题。异常一般是在特定环境下产生的，通常出现在代码的特定方法和操作中。
    > + **Error（错误）**表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题。例如，当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。
    > + Error类一般是指与虚拟机相关的问题，如系统崩溃，虚拟机错误，内存空间不足，方法调用栈溢等。对于这类错误的导致的应用程序中断，仅靠程序本身无法恢复和预防，遇到这样的错误，建议让程序终止。
    > + Exception类表示程序可以处理的异常，可以捕获且可能恢复。遇到这类异常，应该尽可能处理异常，使程序恢复运行，而不应该随意终止异常。
    >
    > **Exception类**
    >
    > 又分为运行时异常（Runtime Exception）和受检查的异常(Checked Exception )。
    >
    > + 运行时异常;ArithmaticException,IllegalArgumentException，编译能通过，但是一运行就终止了，程序不会处理运行时异常，出现这类异常，程序会终止。
    > + 受检查的异常，要么用try。。。catch捕获，要么用throws字句声明抛出，交给它的父类处理，否则编译不会通过。
    >
    > **Checked Exception**
    >
    > 

32. 请列出5个运行时异常。

    > + 错误的类型转换：ClassCastException
    > + 试图使用空值对象引用：NullPointerException
    > + 除数为零：ArithmeticException
    > + 数组越界：ArrayIndexOutOfBoundException。
    >
    > 

33. 在自己的代码中，如果创建一个java.lang.String类，这个类是否可以被类加载器加载？为什么。

    > 答案是**否定的**。
    >
    > 我们不能实现。为什么呢？我看很多网上解释是说双亲委托机制解决这个问题，其实不是非常的准确。因为双亲委托机制是可以打破的，你完全可以自己写一个classLoader来加载自己写的java.lang.String类，但是你会发现也不会加载成功，具体就是因为针对java.*开头的类，jvm的实现中已经保证了必须由bootstrp来加载。
    >
    > 因加载某个类时，优先使用父类加载器加载需要使用的类。如果我们自定义了java.lang.String这个类， 加载该自定义的String类，该自定义String类使用的加载器是AppClassLoader，根据优先使用父类加载器原理， AppClassLoader加载器的父类为ExtClassLoader，所以这时加载String使用的类加载器是ExtClassLoader， 但是类加载器ExtClassLoader在jre/lib/ext目录下没有找到String.class类。然后使用ExtClassLoader父类的加载器BootStrap， 父类加载器BootStrap在JRE/lib目录的rt.jar找到了String.class，将其加载到内存中。这就是类加载器的委托机制。
    >
    > 
    >
    > **双亲委派模型**
    > 类加载器可分为两类：一是启动类加载器(Bootstrap ClassLoader)，是C++实现的，是JVM的一部分；另一种是其它的类加载器，是Java实现的，独立于JVM，全部都继承自抽象类java.lang.ClassLoader。
    >
    > jdk自带了三种类加载器
    >
    > + 启动类加载器（Bootstrap ClassLoader）
    > + 扩展类加载器（Extension ClassLoader）
    > + 应用程序类加载器（Application ClassLoader）。
    > + 后两种加载器是继承自抽象类java.lang.ClassLoader。
    >
    > 一般是： 自定义类加载器 >> 应用程序类加载器 >> 扩展类加载器 >> 启动类加载器
    >
    > 上面的层次关系被称为双亲委派模型(Parents Delegation Model)。除了最顶层的启动类加载器外，其余的类加载器都有对应的父类加载器。
    >
    > 各个类加载器之间是组合关系，并非继承关系。
    >
    > **双亲委托机制**：
    >
    > 如果一个类加载器收到了类加载的请求，它首先不会自己尝试去加载这个类，而是把这个请求委派给父类加载器，每一个层次的类加载器都是加此，因此所有的加载请求最终到达顶层的启动类加载器，只有当父类加载器反馈自己无法完成加载请求时（指它的搜索范围没有找到所需的类），子类加载器才会尝试自己去加载。
    >
    > **为什么要使用这种双亲委托模式呢？**
    >
    > + 双亲委派模型可以确保安全性，可以保证所有的Java类库都是由启动类加载器加载。
    > + 可以避免重复加载，当父亲已经加载了该类的时候，就没有必要子ClassLoader再加载一次。
    >
    > **定义自己的ClassLoader**
    >
    > 因为Java中提供的默认ClassLoader，只加载指定目录下的jar和class，如果我们想加载其它位置的类或jar时，比如：我要加载网络上的一个class文件，通过动态加载到内存之后，要调用这个类中的方法实现我的业务逻辑。在这样的情况下，默认的ClassLoader就不能满足我们的需求了，所以需要定义自己的ClassLoader。
    >
    > 定义自已的类加载器分为两步：
    >
    > 1、继承java.lang.ClassLoader
    >
    > 2、重写父类的findClass方法
    >
    > 读者可能在这里有疑问，父类有那么多方法，为什么偏偏只重写findClass方法？
    >
    > 因为JDK已经在loadClass方法中帮我们实现了ClassLoader搜索类的算法，当在loadClass方法中搜索不到类时，loadClass方法就会调用findClass方法来搜索类，所以我们只需重写该方法即可。如没有特殊的要求，一般不建议重写loadClass搜索类的算法。
    >
    > > 原文链接：https://blog.csdn.net/riemann_/article/details/87653648 

34. 说一说你对java.lang.Object对象中hashCode和equals方法的理解。在什么场景下需要重新实现这两个方法。

35. 在jdk1.5中，引入了泛型，泛型的存在是用来解决什么问题。

    > **意义和作用**有：
    >
    > + 类型的参数化，就是可以把类型像方法的参数那样传递。这一点意义非凡。
    > + 泛型使编译器可以在编译期间对类型进行检查以提高类型安全，减少运行时由于对象类型不匹配引发的异常。
    > + 泛型方法，算法的复用。蛮神奇的。
    >
    > **泛型的引入**
    >
    > 程序开发人员可能把任何类型的对象放进集合容器，所以这些容器在设计的时候只能默认设计成装Object类型对象。
    >
    > 根据多态，容器就能装任何类型的对象了。不过，取出对象时则需求进行强制类型转换，转换成实际的类型。但这样会有很多类型不安全问题，为什么呢？因为编译器没法帮忙做类型检查，导致代码在运行时易于出现ClassCastException异常。
    >
    > 使用泛型时编译器就可以帮忙做很大一部分的类型安全检查工作了，这就避免了很多运行时的ClassCastException异常，程序员也无需记住各种对象的类型和担心类型匹配问题了。同时大部分情况下也不用做类型强制转换工作了。
    >
    > **有界泛型**：
    >
    > 在使用泛型时，我们会有这种需求：需要指定泛型的类型范围。有界类型就是在类型参数部分指定extends或super关键字，这里的extends也含有implements的功能，分别用上限或下限来限制类型范围，从而限制泛型的类型边界。例如：
    >
    > ```java
    > <T extends Animal>	//限定T是Animal的子类
    > ```
    >
    > 多个限定时我们可以使用&来进行分割，这时关键词只能使用extends。与多重继承类似，这里只可以有一个类，其他都是接口。
    >
    > **泛型方法**
    >
    > 我们设计的方法可能其参数类型是不限定的。这种场景如果用重载方法的方式来做的话，算法重复，不是最好的方案。

36. 这样的a.hashcode() 有什么用，与a.equals(b)有什么关系。

37. 有没有可能2个不相等的对象有相同的hashcode。

    > hashCode是所有java对象的固有方法，如果不重载的话，返回的实际上是该对象在jvm的堆上的内存地址，而不同对象的内存地址肯定不同，所以这个hashCode也就肯定不同了。如果重载了的话，由于采用的算法的问题，有可能导致两个不同对象的hashCode相同。
    >
    > **hashCode() 和 equal()**
    >
    > + hashCode和equals两个方法是有语义关联的，它们需要满足：
    >
    >   A.equals(B)==true --> A.hashCode()==B.hashCode()
    >
    >   因此重载其中一个方法时也需要将另一个也重载。
    >
    > + hashCode的重载实现需要满足不变性，即一个object的hashCode不能前一会是1，过一会就变成2了。hashCode的重载实现最好依赖于对象中的final属性，从而在对象初始化构造后就不再变化。一方面是jvm便于代码优化，可以缓存这个hashCode；另一方面，在使用hashMap或hashSet的场景中，如果使用的key的hashCode会变化，将会导致bug，比如放进去时key.hashCode()=1，等到要取出来时key.hashCode()=2了，就会取不出来原先的数据。这个可以写一个简单的代码自己验证一下。
    >
    > 1、如果两个对象equals，Java运行时环境会认为他们的hashcode一定相等。
    > 2、如果两个对象不equals，他们的hashcode有可能相等。
    > 3、如果两个对象hashcode相等，他们不一定equals。
    > 4、如果两个对象hashcode不相等，他们一定不equals。

38. Java中的HashSet内部是如何工作的。

    > HashSet中不允许有重复元素，这是因为**HashSet是基于HashMap实现的**，HashSet中的元素都存放在HashMap的key上面，而value中的值都是统一的一个**private static final Object PRESENT = new Object();**。HashSet跟HashMap一样，都是一个存放链表的数组。

39. 什么是序列化，怎么序列化，为什么序列化，反序列化会遇到什么问题，如何解决。

    > 序列化是为了保持对象在内存中的状态，并且可以把保存的对象状态再读出来。
    >
    > 1、什么时候需要用到序列化？
    >  a、数据持久化：比如一个电商平台，有数万个用户并发访问的时候会产生数万个session      对象，这个时候内存的压力是很大的。我们可以把session对象序列化到硬盘中,需要时在反序列化，减少内存压力。
    >  b、网络传输：我们将系统拆分成多个服务之后，服务之间传输对象，不管是何种类型的数据，都必须要转成二进制流来传输，接受方收到后再转为数据对象。
    >
    > 简单来说序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化，流的概念这里不用多说(就是I/O)，我们可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间**(注：要想将对象传输于网络必须进行流化)**！在对对象流进行读写操作时会引发一些问题，而序列化机制正是用来解决这些问题的！
    >
    > **反序列化会遇到什么问题，如何解决**
    >
    > Java的序列化机制是通过在运行时判断类的serialVersionUID来验证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体（类）的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常。(InvalidCastException)

40. java8的新特性。

    > > 参考：https://www.jianshu.com/p/5b800057f2d8
    >
    > **语言新特性**
    >
    > + Lambda表达式和函数式接口
    > + 接口的默认方法和静态方法
    >   + 默认方法使得开发者可以在 不破坏二进制兼容性的前提下，往现存接口中添加新的方法，即不强制那些实现了该接口的类也同时实现这个新加的方法。
    >   + 默认方法和抽象方法之间的区别在于抽象方法需要实现，而默认方法不需要。接口提供的默认方法会被接口的实现类继承或者覆写。
    >   + 

## **JVM知识**

1. 什么情况下会发生栈内存溢出。

   > 

2. JVM的内存结构，Eden和Survivor比例。

3. JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor。

4. JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代，说说你知道的几种主要的JVM参

5. 数。

6. 你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，包括原理，流程，优缺点。

7. 垃圾回收算法的实现原理。

8. 当出现了内存溢出，你怎么排错。

9. JVM内存模型的相关知识了解多少，比如重排序，内存屏障，happen-before，主内存，工作

10. 内存等。

11. 简单说说你了解的类加载器，可以打破双亲委派么，怎么打破。

12. 讲讲JAVA的反射机制。

13. 你们线上应用的JVM参数有哪些。

14. g1和cms区别,吞吐量优先和响应优先的垃圾收集器选择。

15. 怎么打出线程栈信息。

16. 请解释如下jvm参数的含义：

17. -server -Xms512m -Xmx512m -Xss1024K

18. -XX:PermSize=256m -XX:MaxPermSize=512m -

19. XX:MaxTenuringThreshold=20XX:CMSInitiatingOccupancyFraction=80 -

20. XX:+UseCMSInitiatingOccupancyOnly。

## **开源框架知识**

1. 简单讲讲tomcat结构，以及其类加载器流程，线程模型等。
2. tomcat如何调优，涉及哪些参数 。
3. 讲讲Spring加载流程。
4. Spring AOP的实现原理。
5. 讲讲Spring事务的传播属性。
6. Spring如何管理事务的。
7. Spring怎么配置事务（具体说出一些关键的xml 元素）。
8. 说说你对Spring的理解，非单例注入的原理？它的生命周期？循环注入的原理，aop的实现原
9. 理，说说aop中的几个术语，它们是怎么相互工作的。
10. Springmvc 中DispatcherServlet初始化过程。
11. netty的线程模型，netty如何基于reactor模型上实现的。
12. 为什么选择netty。
13. 什么是TCP粘包，拆包。解决方式是什么。
14. netty的fashwheeltimer的用法，实现原理，是否出现过调用不够准时，怎么解决。
15. netty的心跳处理在弱网下怎么办。
16. netty的通讯协议是什么样的。
17. springmvc用到的注解，作用是什么，原理。
18. springboot启动机制。
19. 点击这里有一套答案版的Spring试题。

## **操作系统**

1. Linux系统下你关注过哪些内核参数，说说你知道的。

   > proc/sys/net/core/rmem_max — 最大的TCP数据接收缓冲 

2. Linux下IO模型有几种，各自的含义是什么。

   > **同步模型（synchronous IO）**
   >
   > 阻塞IO（bloking IO）
   >
   > 非阻塞IO（non-blocking IO）
   >
   > 多路复用IO（multiplexing IO）
   >
   > 信号驱动式IO（signal-driven IO）
   >
   > **异步IO（asynchronous IO）**

3. epoll和poll有什么区别。

   > 

4. 平时用到哪些Linux命令。

   > + 目录切换命令
   > + 目录操作命令（增删改查）
   > + 文件的操作命令（增删改查）
   > + 压缩文件的操作命令（压缩和解压缩）
   > + Linux的文件权限命令
   > + Linux用户管理
   > + 进程相关命令

5. 用一行命令查看文件的最后五行。

   > tail -5 文件名

6. 用一行命令输出正在运行的java进程。

   > ps -ef | grep java

7. 介绍下你理解的操作系统中线程切换过程。

   > **什么引起线程切换**
   >
   > - 时间片轮转
   > - 线程阻塞
   > - 线程主动放弃时间片
   >
   > **线程切换的开销**
   >
   > **直接开销**
   >
   > + **用户态与内核态的切换**：线程切换只能在内核态完成，如果当前用户处于用户态，则必然引起用户态与内核态的切换。
   >
   > + **上下文切换**
   >
   >   线程（或者叫做进程都随意）信息需要用一个`task_struct`保存，线程切换时，必然需要将旧线程的`task_struct`从内核切出，将新线程的切入，带来上下文切换。除此之外，还需要切换寄存器、程序计数器、线程栈（包括操作栈、数据栈）等。
   >
   > + **线程调度算法**
   >
   >   线程调度算法需要管理线程的状态、等待条件等，如果根据优先级调度，则还需要维护优先级队列。如果线程切换比较频繁，该成本不容小觑。
   >
   > **间接开销**
   >
   > + **缓存缺失**
   >
   >   切换进程，需要执行新逻辑。如果二者的访问的地址空间不相近，则会引起缓存缺失，具体影响范围取决于系统实现和用户代码实现。如果系统的缓存较大，则能减小缓存缺失的影响；如果用户线程访问数据的地址空间接近，则本身的缓存缺失率也比较低。

8. 进程和线程的区别。

   > + **进程是操作系统的管理单位，而线程则是进程的管理单位**；一个进程至少包含一个执行线程。
   > + 不管是在单线程还是多线程中，**每个线程都有一个程序计数器（记录要执行的下一条指令），一组寄存器（保存当前线程的工作变量），堆栈（记录执行历史，其中每一帧保存了一个已经调用但未返回的过程）**。
   > + 虽然线程寄生在进程中，但与他的进程是不同的概念，并且可以分别处理：**进程是系统分配资源的基本单位，线程是调度CPU的基本单位**。
   > + **线程划分尺度小于进程**，线程隶属于某个进程；
   > + **进程是CPU、内存等资源占用的基本单位**，线程是不能独立占有这些资源的；
   > + **进程之间相互独立，通信比较困难**，而线程之间共享一块内存区域，通信方便；
   > + **进程在执行过程中**，包含：**固定的入口、执行顺序和出口**，**而进程的这些过程会被应用程序控制**；
   > + 进程是资源分配的基本单位
   > + 线程是CPU调度的基本单位
   > + 一个进程下可能有多个线程
   > + 线程共享进程的资源

9. 用户态和核心态的转换

   > 用户态切换到核心态有三种方式： 
   >
   > **a.系统调用**
   >  这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作。
   >
   > 比如前例中fork()实际上就是执行了一个创建新进程的系统调用。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断。 
   >
   > **b.异常**
   >  当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态。
   >
   > 比如缺页异常。 
   >
   > **c.外围设备的中断**
   >  当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。
   >
   > 比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。

10. top 命令之后有哪些内容，有什么作用。

    > **命令格式：**
    >
    > ```shell
    > top [参数]
    > ```
    >
    > **2．命令功能：**
    >
    > 显示当前系统正在执行的进程的相关信息，包括进程ID、内存占用率、CPU占用率等
    >
    > **3．命令参数：**
    >
    > -b 批处理
    >
    > -c 显示完整的治命令
    >
    > -I 忽略失效过程
    >
    > -s 保密模式
    >
    > -S 累积模式
    >
    > -i<时间> 设置间隔时间
    >
    > -u<用户名> 指定用户名
    >
    > -p<进程号> 指定进程
    >
    > -n<次数> 循环显示的次数
    >
    > **4．输出：**
    >
    > + 第一行：任务队列信息，同 uptime 命令的执行结果
    > + 第二行：Tasks — 全局任务（进程）信息
    > + 第三行：cpu状态信息
    > + 第四行：内存状态
    > + 第五行：swap交换分区信息
    > + 第六行：空行
    > + 第七行以下：各进程（任务）的状态监控

11. 线上CPU爆高，请问你如何找到问题所在。

    > 线上CPU负载过高，代码层面常见的**场景**有：
    >
    > 1. 程序陷入死循环，不停地消耗CPU
    > 2. 线程死锁，线程相互等待，导致假死状态，不停地消耗CPU
    >
    > **排查：**
    >
    > + 在 `linux` 命令行键入 `top` 指令后，就开始实时监控当前系统的负载信息
    > + `top -H -p pid`: 查看指定进程中每个线程的资源占用情况(每条线程占用CPU时间的百分比)，
    > + `printf “0x%x\n”线程PID`： 0×431 // 将线程PID转换为 16进制，为后面查找 jstack 日志做准备
    > + `jstack 17499 > ./threadDump.log`：将线程堆栈信息输出到当前目录下的 threadDump.log 文件。快速把堆栈信息输出到日志文本中，保留日志信息，然后迅速先重启服务，达到临时缓解服务器压力的目的。

## **多线程**

1. 多线程的几种实现方式，什么是线程安全。
2. volatile的原理，作用，能代替锁么。
3. 画一个线程的生命周期状态图。
4. sleep和wait的区别。
5. sleep和sleep(0)的区别。
6. Lock与Synchronized的区别 。
7. synchronized的原理是什么，一般用在什么地方(比如加在静态方法和非静态方法的区别，静
8. 态方法和非静态方法同时执行的时候会有影响吗)，解释以下名词：重排序，自旋锁，偏向锁，轻
9. 量级锁，可重入锁，公平锁，非公平锁，乐观锁，悲观锁。
10. 用过哪些原子类，他们的原理是什么。
11. JUC下研究过哪些并发工具，讲讲原理。
12. 用过线程池吗，如果用过，请说明原理，并说说newCache和newFixed有什么区别，构造函
13. 数的各个参数的含义是什么，比如coreSize，maxsize等。
14. 线程池的关闭方式有几种，各自的区别是什么。
15. 假如有一个第三方接口，有很多个线程去调用获取数据，现在规定每秒钟最多有10个线程同
16. 时调用它，如何做到。
17. spring的controller是单例还是多例，怎么保证并发的安全。
18. 用三个线程按顺序循环打印abc三个字母，比如abcabcabc。
19. ThreadLocal用过么，用途是什么，原理是什么，用的时候要注意什么。
20. 如果让你实现一个并发安全的链表，你会怎么做。
21. 有哪些无锁数据结构，他们实现的原理是什么。
22. 讲讲java同步机制的wait和notify。
23. CAS机制是什么，如何解决ABA问题。
24. 多线程如果线程挂住了怎么办。
25. countdowlatch和cyclicbarrier的内部原理和用法，以及相互之间的差别(比如
26. countdownlatch的await方法和是怎么实现的)。
27. 对AbstractQueuedSynchronizer了解多少，讲讲加锁和解锁的流程，独占锁和公平所
28. 加锁有什么不同。
29. 使用synchronized修饰静态方法和非静态方法有什么区别。
30. 简述ConcurrentLinkedQueue和LinkedBlockingQueue的用处和不同之处。
31. 导致线程死锁的原因？怎么解除线程死锁。
32. 非常多个线程（可能是不同机器），相互之间需要等待协调，才能完成某种工作，问怎么设计这种协调方案。
33. 用过读写锁吗，原理是什么，一般在什么场景下用。
34. 开启多个线程，如果保证顺序执行，有哪几种实现方式，或者如何保证多个线程都执行完
35. 再拿到结果。
36. 延迟队列的实现方式，delayQueue和时间轮算法的异同。
37. 点击这里有一套答案版的多线程试题。

## **TCP与HTTP**

1. http1.0和http1.1有什么区别。
2. TCP三次握手和四次挥手的流程，为什么断开连接要4次,如果握手只有两次，会出现什么。
3. TIME_WAIT和CLOSE_WAIT的区别。
4. 说说你知道的几种HTTP响应码，比如200, 302, 404。
5. 当你用浏览器打开一个链接（如：http://www.javastack.cn）的时候，计算机做了哪些工作步骤。
6. TCP/IP如何保证可靠性，说说TCP头的结构。
7. 如何避免浏览器缓存。
8. 如何理解HTTP协议的无状态性。
9. 简述Http请求get和post的区别以及数据包格式。
10. HTTP有哪些method
11. 简述HTTP请求的报文格式。
12. HTTP的长连接是什么意思。
13. HTTPS的加密方式是什么，讲讲整个加密解密流程。
14. Http和https的三次握手有什么区别。
15. 什么是分块传送。
16. Session和cookie的区别。
17. 点击这里有一套答案版的试题。

## **架构设计与分布式**

1. 用java自己实现一个LRU。
2. 分布式集群下如何做到唯一序列号。
3. 设计一个秒杀系统，30分钟没付款就自动关闭交易。
4. 如何使用redis和zookeeper实现分布式锁？有什么区别优缺点，会有什么问题，分别适用什么
5. 场景。（延伸：如果知道redlock，讲讲他的算法实现，争议在哪里）
6. 如果有人恶意创建非法连接，怎么解决。
7. 分布式事务的原理，优缺点，如何使用分布式事务，2pc 3pc 的区别，解决了哪些问题，还有
8. 哪些问题没解决，如何解决，你自己项目里涉及到分布式事务是怎么处理的。
9. 什么是一致性hash。
10. 什么是restful，讲讲你理解的restful。
11. 如何设计一个良好的API。
12. 如何设计建立和保持100w的长连接。
13. 解释什么是MESI协议(缓存一致性)。
14. 说说你知道的几种HASH算法，简单的也可以。
15. 什么是paxos算法， 什么是zab协议。
16. 一个在线文档系统，文档可以被编辑，如何防止多人同时对同
17. 一份文档进行编辑更新。
18. 线上系统突然变得异常缓慢，你如何查找问题。
19. 说说你平时用到的设计模式。
20. Dubbo的原理，有看过源码么，数据怎么流转的，怎么实现集群，负载均衡，服务注册
21. 和发现，重试转发，快速失败的策略是怎样的 。
22. 一次RPC请求的流程是什么。
23. 自己实现过rpc么，原理可以简单讲讲。Rpc要解决什么问题。
24. 异步模式的用途和意义。
25. 编程中自己都怎么考虑一些设计原则的，比如开闭原则，以及在工作中的应用。
26. 设计一个社交网站中的“私信”功能，要求高并发、可扩展等等。 画一下架构图。
27. MVC模式，即常见的MVC框架。
28. 聊下曾经参与设计的服务器架构并画图，谈谈遇到的问题，怎么解决的。
29. 应用服务器怎么监控性能，各种方式的区别。
30. 如何设计一套高并发支付方案，架构如何设计。
31. 如何实现负载均衡，有哪些算法可以实现。
32. Zookeeper的用途，选举的原理是什么。
33. Zookeeper watch机制原理。
34. Mybatis的底层实现原理。
35. 请思考一个方案，实现分布式环境下的countDownLatch。
36. 后台系统怎么防止请求重复提交。
37. 描述一个服务从发布到被消费的详细过程。
38. 讲讲你理解的服务治理。
39. 如何做到接口的幂等性。
40. 如何做限流策略，令牌桶和漏斗算法的使用场景。
41. 什么叫数据一致性，你怎么理解数据一致性。
42. 分布式服务调用方，不依赖服务提供方的话，怎么处理服务方挂掉后，大量无效资源请求
43. 的浪费，如果只是服务提供方吞吐不高的时候该怎么做，如果服务挂了，那么一会重启，该怎
44. 么做到最小的资源浪费，流量半开的实现机制是什么。
45. dubbo的泛化调用怎么实现的，如果是你，你会怎么做。
46. 远程调用会有超时现象，如果做到优雅的控制，JDK自带的超时机制有哪些，怎么实现的。

## **算法**

1. 10亿个数字里里面找最小的10个。
2. 有1亿个数字，其中有2个是重复的，快速找到它，时间和空间要最优。
3. 2亿个随机生成的无序整数,找出中间大小的值。
4. 给一个不知道长度的（可能很大）输入字符串，设计一种方案，将重复的字符排重。
5. 遍历二叉树。
6. 有3n+1个数字，其中3n个中是重复的，只有1个是不重复的，怎么找出来。
7. 写一个字符串（如：www.javastack.cn）反转函数。
8. 常用的排序算法，快排，归并、冒泡。 快排的最优时间复杂度，最差复杂度。冒泡排序的
9. 优化方案。
10. 二分查找的时间复杂度，优势。
11. 一个已经构建好的TreeSet，怎么完成倒排序。
12. 什么是B+树，B-树，列出实际的使用场景。
13. 一个单向链表，删除倒数第N个数据。
14. 200个有序的数组，每个数组里面100个元素，找出top20的元素。
15. 单向链表，查找中间的那个元素。

## **数据库知识**

1. 并发事务会带来哪些问题？

   > 多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。
   >
   > - **脏读（Dirty read）:** 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。
   >
   >   (**读取了没有提交的数据**)
   >
   > - **丢失修改（Lost to modify）:** 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。
   >
   >   （**两个数据先后读取数据然后修改数据，导致第二个事务将第一个事务的修改覆盖**）
   >
   > - **不可重复读（Unrepeatableread）:** 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了**在一个事务内两次读到的数据是不一样的情况**，因此称为不可重复读。
   >
   > - **幻读（Phantom read）:** 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在**随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样**，所以称为幻读。

2. 数据库隔离级别有哪些，各自的含义是什么，MYSQL默认的隔离级别是是什么。

   > **SQL 标准定义了四个隔离级别：**
   >
   > - **READ-UNCOMMITTED(读取未提交)：** 最低的隔离级别，允许读取尚未提交的数据变更，**可能会导致脏读、幻读或不可重复读**。
   > - **READ-COMMITTED(读取已提交)：** 允许读取并发事务已经提交的数据，**可以阻止脏读，但是幻读或不可重复读仍有可能发生**。
   > - **REPEATABLE-READ(可重复读)：** 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，**可以阻止脏读和不可重复读，但幻读仍有可能发生**。
   > - **SERIALIZABLE(可串行化)：** 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，**该级别可以防止脏读、不可重复读以及幻读**。
   >
   > MySQL InnoDB 存储引擎的默认支持的隔离级别是 **REPEATABLE-READ（可重读）**。我们可以通过`SELECT @@tx_isolation;`命令来查看。
   >
   > 与 SQL 标准不同的地方在于 InnoDB 存储引擎在 **REPEATABLE-READ（可重读）** 事务隔离级别下使用的是Next-Key Lock 锁算法，因此可以避免幻读的产生，这与其他数据库系统(如 SQL Server) 是不同的。所以说InnoDB 存储引擎的默认支持的隔离级别是 **REPEATABLE-READ（可重读）** 已经可以完全保证事务的隔离性要求，即达到了 SQL标准的 **SERIALIZABLE(可串行化)** 隔离级别。因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是 **READ-COMMITTED(读取提交内容)** ，但是你要知道的是InnoDB 存储引擎默认使用 **REPEAaTABLE-READ（可重读）** 并不会有任何性能损失。

3. MYSQL有哪些存储引擎，各自优缺点。

   > **MyISAM和InnoDB区别**
   >
   > MyISAM是MySQL的默认数据库引擎（5.5版之前）。虽然性能极佳，而且提供了大量的特性，包括全文索引、压缩、空间函数等，但MyISAM不支持事务和行级锁，而且最大的缺陷就是崩溃后无法安全恢复。不过，5.5版本之后，MySQL引入了InnoDB（事务性数据库引擎），MySQL 5.5版本后默认的存储引擎为InnoDB。
   >
   > 大多数时候我们使用的都是 InnoDB 存储引擎，但是在某些情况下使用 MyISAM 也是合适的比如读密集的情况下。（如果你不介意 MyISAM 崩溃恢复问题的话）。
   >
   > **两者的对比：**
   >
   > 1. **是否支持行级锁** : MyISAM 只有表级锁(table-level locking)，而InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。
   > 2. **是否支持事务和崩溃后的安全恢复： MyISAM** 强调的是性能，每次查询具有原子性,其执行速度比InnoDB类型更快，但是不提供事务支持。但是**InnoDB** 提供事务支持事务，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。
   > 3. **是否支持外键：** MyISAM不支持，而InnoDB支持。
   > 4. **是否支持MVCC** ：仅 InnoDB 支持。应对高并发事务, MVCC比单纯的加锁更高效;MVCC只在 `READ COMMITTED` 和 `REPEATABLE READ` 两个隔离级别下工作;MVCC可以使用 乐观(optimistic)锁 和 悲观(pessimistic)锁来实现;各数据库中MVCC实现并不统一。

4. 高并发下，如何做到安全的修改同一行数据。

   > 

5. 乐观锁和悲观锁是什么，INNODB的标准行级锁有哪2种，解释其含义。

   > **乐观锁**
   >
   > 悲观锁（Pessimistic Lock），顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。
   >
   > 悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。
   >
   > Java synchronized 就属于悲观锁的一种实现，每次线程要修改数据时都先获得锁，保证同一时刻只有一个线程能操作数据，其他线程则会被block。
   >
   > **悲观锁**
   >
   > 乐观锁（Optimistic Lock），顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。乐观锁适用于读多写少的应用场景，这样可以提高吞吐量。
   >
   > 乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。
   >
   > **实现方式**
   >
   > + 使用数据版本（Version）记录机制实现。
   > + 使用时间戳（timestamp）。
   >
   > **InnoDB实现了以下两种类型的行锁**：
   >
   > - **共享锁（S）**：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。
   > - **排他锁（X)**：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。
   >
   > 为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是表锁。
   >
   > + **意向共享锁（IS**）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。
   > + **意向排他锁（IX）**：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。

6. SQL优化的一般步骤是什么，怎么看执行计划，如何理解其中各个字段的含义。

7. 数据库会死锁吗，举一个死锁的例子，mysql怎么解决死锁。

8. MYsql的索引原理，索引的类型有哪些，如何创建合理的索引，索引如何优化。

   > **Mysql 的基本存储结构**
   >
   > - 基本存储结构是页(记录都存在页里边)。
   >
   > - 各个数据页可以组成一个双向链表
   >
   > - 每个数据页中的记录又可以组成一个单向链表
   >
   >   - 每个数据页都会为存储在它里边儿的记录生成一个页目录，在通过主键查找某条记录的时候可以在页目录中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录
   >   - 以其他列(非主键)作为搜索条件：只能从最小记录开始依次遍历单链表中的每条记录。
   >
   > - 如果我们写select * from user where indexname = 'xxx'这样没有进行任何优化的sql语句，默认会这样做：
   >
   >   + 定位到记录所在的页：需要遍历双向链表，找到所在的页
   >
   >   + 从所在的页内中查找相应的记录：由于不是根据主键查询，只能遍历所在页的单链表了。这样查找会很慢，时间复杂度为O（n）
   >
   > **索引**
   >
   > 索引的思路就是将无序的数据变成有序(相对)，来查询加快速度。底层结构就是B+树，B+树作为树的一种实现，能够让我们很快地查找出对应的记录。（二分查找，时间复杂度近似为O(logn)）
   >
   > **索引优化**
   >
   > + **最左前缀原则**：MySQL中的索引可以以一定顺序引用多列，这种索引叫作联合索引。最左前缀原则指的是，如果查询的时候查询条件精确匹配索引的左边连续一列或几列，则此列就可以被用到。
   >
   >   由于最左前缀原则，在创建联合索引时，索引字段的顺序需要考虑字段值去重之后的个数，较多的放前面。ORDER BY子句也遵循此规则。
   >
   > + **注意避免冗余索引**：冗余索引指的是索引的功能相同，能够命中 就肯定能命中 。MySQL 5.7 版本后，可以通过查询 sys 库的 `schema_redundant_indexes` 表来查看冗余索引。
   >
   > **索引类型**
   >
   > **从数据结构的角度**
   >
   > + **B+树索引**(O(log(n)))
   > + **hash索引**：
   >   + 仅仅能满足"=","IN"和"<=>"查询，不能使用范围查询
   >   + 其检索效率非常高，索引的检索可以一次定位，不像B-Tree 索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问，所以 Hash 索引的查询效率要远高于 B-Tree 索引
   >   + 只有Memory存储引擎显示支持hash索引
   > + **FULLTEXT索引**（现在MyISAM和InnoDB引擎都支持了）
   > + **R-Tree索引**（用于对GIS数据类型创建SPATIAL索引）
   >
   > **从物理存储角度**
   >
   > + **聚集索引（clustered index）**
   > + **非聚集索引（non-clustered index）**
   >
   > **从逻辑角度**
   >
   > **从逻辑角度**
   >
   > + 主键索引：主键索引是一种特殊的唯一索引，不允许有空值
   >
   > + 普通索引或者单列索引
   > + 多列索引（复合索引）：复合索引指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用复合索引时遵循最左前缀集合
   > + 唯一索引或者非唯一索引
   > + 空间索引：空间索引是对空间数据类型的字段建立的索引，MYSQL中的空间数据类型有4种，分别是GEOMETRY、POINT、LINESTRING、POLYGON。
   >   MYSQL使用SPATIAL关键字进行扩展，使得能够用于创建正规索引类型的语法创建空间索引。创建空间索引的列，必须将其声明为NOT NULL，空间索引只能在存储引擎为MYISAM的表中创建
   >
   > ```sql
   > CREATE TABLE table_name[col_name data type]
   > [unique|fulltext|spatial][index|key][index_name](col_name[length])[asc|desc]
   > ```
   >
   > 1、unique|fulltext|spatial为可选参数，分别表示唯一索引、全文索引和空间索引；
   >
   > 2、index和key为同义词，两者作用相同，用来指定创建索引
   >
   > 3、col_name为需要创建索引的字段列，该列必须从数据表中该定义的多个列中选择；
   >
   > 4、index_name指定索引的名称，为可选参数，如果不指定，MYSQL默认col_name为索引值；
   >
   > 5、length为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度；
   >
   > 6、asc或desc指定升序或降序的索引值存储

9. 聚集索引和非聚集索引的区别。

   > **聚集索引**
   >
   > 数据行的物理顺序与列值（一般是主键的那一列）的逻辑顺序相同，一个表中只能拥有一个聚集索引。
   >
   > **优点**是查询速度快，因为一旦具有第一个索引值的纪录被找到，具有连续索引值的记录也一定物理的紧跟其后。
   >
   > **缺点**是对表进行修改速度较慢，这是为了保持表中的记录的物理顺序与索引的顺序一致，而把记录插入到数据页的相应位置，必须在数据页中进行数据重排， 降低了执行速度。
   >
   > 建议使用聚集索引的场合为：
   >
   > + 此列包含有限数目的不同值；
   >
   > + 查询的结果返回一个区间的值；
   >
   > + 查询的结果返回某值相同的大量结果集。
   >
   > 
   >
   > **非聚集索引**
   >
   > **非聚集索引指定了表中记录的逻辑顺序，但记录的物理顺序和索引的顺序不一致**，聚集索引和非聚集索引都采用了B+树的结构，但非聚集索引的叶子层并不与实际的数据页相重叠，而采用叶子层包含一个指向表中的记录在数据页中的指针的方式。
   >
   > 非聚集索引比聚集索引层次多，添加记录不会引起数据顺序的重组。
   >  建议使用非聚集索引的场合为：
   >
   > + 此列包含了大量数目不同的值；
   > + 查询的结束返回的是少量的结果集；
   > + order by 子句中使用了该列。
   >
   > 
   >
   > 

10. select for update 是什么含义，会锁表还是锁行或是其他。

    > 表示**排他锁**
    >
    > 排他锁的**申请前提**：没有线程对该结果集中的任何行数据使用排他锁或共享锁，否则申请会阻塞。
    >
    > for update仅适用于InnoDB，且必须在事务块(BEGIN/COMMIT)中才能生效。在进行事务操作时，通过“for update”语句，MySQL会对查询结果集中每行数据都添加排他锁，其他线程对该记录的更新与删除操作都会阻塞。排他锁包含行锁、表锁。
    > **产生表锁还是行锁？**
    >
    > **不一定**。
    >
    > + InnoDB行锁是通过给索引上的索引项加锁来实现的，只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁。
    >
    > + 由于MySQL的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然是访问不同行的记录，但是如果是使用相同的索引键，是会出现锁冲突的。应用设计的时候要注意这一点。
    >
    > + 当表有多个索引的时候，不同的事务可以使用不同的索引锁定不同的行，另外，不论是使用主键索引、唯一索引或普通索引，InnoDB都会使用行锁来对数据加锁。
    >
    > + 即便在条件中使用了索引字段，但是否使用索引来检索数据是由MySQL通过判断不同执行计划的代价来决定的，如果MySQL认为全表扫描效率更高，比如对一些很小的表，它就不会使用索引，这种情况下InnoDB将使用表锁，而不是行锁。因此，在分析锁冲突时，别忘了检查SQL的执行计划，以确认是否真正使用了索引。
    >
    > + 检索值的数据类型与索引字段不同，虽然MySQL能够进行数据类型转换，但却不会使用索引，从而导致InnoDB使用表锁。通过用explain检查两条SQL的执行计划，我们可以清楚地看到了这一点。
    >
    >   > 参考：https://blog.csdn.net/claram/article/details/54023216 

11. 为什么要用Btree实现，它是怎么分裂的，什么时候分裂，为什么是平衡的。

    > 

12. 数据库的ACID是什么。

    > + **原子性（Atomicity）：** 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；
    >
    > + **一致性（Consistency）：** 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；
    >
    > + **隔离性（Isolation）：** 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；
    >
    > + **持久性（Durability）：** 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。

13. 某个表有近千万数据，CRUD比较慢，如何优化。

14. Mysql怎么优化table scan的。

15. 如何写sql能够有效的使用到复合索引。

16. mysql中in 和exists 区别。

17. 数据库自增主键可能的问题。

18. MVCC的含义，如何实现的。

19. 你做过的项目里遇到分库分表了吗，怎么做的，有用到中间件么，比如sharding jdbc等,他们的原理知道么。

20. MYSQL的主从延迟怎么解决。

## **消息队列**

1. 消息队列的使用场景。
2. 消息的重发，补充策略。
3. 如何保证消息的有序性。
4. 用过哪些MQ，和其他mq比较有什么优缺点，MQ的连接是线程安全的吗，你们公司的MQ服务
5. 架构怎样的。
6. MQ系统的数据如何保证不丢失。
7. rabbitmq如何实现集群高可用。
8. kafka吞吐量高的原因。
9. kafka 和其他消息队列的区别，kafka 主从同步怎么实现。
10. 利用mq怎么实现最终一致性。
11. 使用kafka有没有遇到什么问题，怎么解决的。
12. MQ有可能发生重复消费，如何避免，如何做到幂等。
13. MQ的消息延迟了怎么处理，消息可以设置过期时间么，过期了你们一般怎么处理。

## **缓存**

1. 常见的缓存策略有哪些，如何做到缓存(比如redis)与DB里的数据一致性，你们项目中用到了
2. 什么缓存系统，如何设计的。
3. 如何防止缓存击穿和雪崩。
4. 缓存数据过期后的更新如何设计。
5. redis的list结构相关的操作。
6. Redis的数据结构都有哪些。
7. Redis的使用要注意什么，讲讲持久化方式，内存设置，集群的应用和优劣势，淘汰策略等。
8. redis2和redis3的区别，redis3内部通讯机制。
9. 当前redis集群有哪些玩法，各自优缺点，场景。
10. Memcache的原理，哪些数据适合放在缓存中。
11. redis和memcached 的内存管理的区别。
12. Redis的并发竞争问题如何解决，了解Redis事务的CAS操作吗。
13. Redis的选举算法和流程是怎样的。
14. redis的持久化的机制，aof和rdb的区别。
15. redis的集群怎么同步的数据的。
16. 知道哪些redis的优化操作。
17. Reids的主从复制机制原理。
18. Redis的线程模型是什么。
19. 请思考一个方案，设计一个可以控制缓存总体大小的自动适应的本地缓存。
20. 如何看待缓存的使用（本地缓存，集中式缓存），简述本地缓存和集中式缓存和优缺点。
21. 本地缓存在并发使用时的注意事项。

## **搜索**

1. elasticsearch了解多少，说说你们公司es的集群架构，索引数据大小，分片有多少，以及一些调优手段 。elasticsearch的倒排索引是什么。

2. elasticsearch 索引数据多了怎么办，如何调优，部署。

   > **索引效率优化**
   >
   > + 批量提交
   >
   >   + 当有大量数据提交的时候，建议采用批量提交。优化 size 大小需要根据文档大小和服务器性能而定。
   >
   > + 优化硬件
   >
   >   + 优化硬件设备一直是最快速有效的手段。在经济压力能承受的范围下， 尽量使用固态硬盘 SSD。SSD 相对于机器硬盘，无论随机写还是顺序写，都较大的提升。
   >
   > + 增加 Refresh 时间间隔
   >
   >   + 为了提高索引性能，Elasticsearch 在写入数据时候，采用**延迟写入**的策略，即数据先写到内存中，当超过默认 1 秒 （index.refresh_interval）会进行一次写入操作，就是将内存中 segment 数据刷新到操作系统中，此时我们才能将数据搜索出来，所以这就是为什么 Elasticsearch 提供的是**近实时**搜索功能，而不是实时搜索功能。
   >
   >   + 当然像我们的内部系统对数据延迟要求不高的话，我们可以通过**延长 refresh 时间间隔**，可以有效的减少 segment 合并压力，提供索引速度。在做全链路跟踪的过程中，我们就将 index.refresh_interval 设置为 30s，减少 refresh 次数。
   >
   >   + 同时，在进行全量索引时，可以将 **refresh 次数临时关闭**，即 index.refresh_interval 设置为 -1，数据导入成功后再打开到正常模式，比如 30s。
   >
   > + 「选择恰当的分片数量和分片副本数量」，减少副本数量
   >
   >   + Elasticsearch 副本数量为 3多个时，虽然这样会提高集群的可用性，增加搜索的并发数，但是同时也会影响写入索引的效率。
   >   + 分片数太少，扛不住大的吞吐量
   >   +  ES7.0 默认的分片方案也是朝着这个方面走的，所以我觉得方案调整应该是经过一段时间的实践，考虑到大部分场景下`1 Shard + 1 Replica`这样的方案是更高的选择。
   >
   > **查询效率优化**
   >
   > **查询机制**
   >
   > + 查询文档的时候，Elasticsearch 通过下面这个公式来计算出来文档应该存放到哪个分片：
   >
   >   > shard = hash(routing) % number_of_primary_shards
   >
   >   routing 默认值是文档的 id，也可以采用自定义值，比如用户 id。
   >
   > + 不带 routing 查询：在查询的时候因为不知道要查询的数据具体在哪个分片上，所以整个过程分为 2 个步骤
   >
   >   + 分发：请求到达协调节点后，协调节点将查询请求分发到每个分片上。
   >   + 聚合: 协调节点搜集到每个分片上查询结果，在将查询的结果进行排序，之后给用户返回结果。
   >
   > + 带 routing 查询
   >
   >   + 查询的时候，可以直接根据 routing 信息定位到某个分配查询，不需要查询所有的分配，经过协调节点排序。
   >
   > + Filter VS Query：Use filter context instead of query context if possible.
   >
   >   + Query：此文档与此查询子句的匹配程度如何？
   >
   >   + Filter：此文档和查询子句匹配吗？
   >
   >   + Elasticsearch 针对 Filter 查询只需要回答「是」或者「否」，不需要像 Query 查询一下计算相关性分数，同时 Filter 结果可以缓存。
   >
   >   + 在一般情况下，一个 filter （过滤查询）会比一个评分的 query （评分查询）性能更优异，并且每次都表现的很稳定。
   >
   >     过滤（filtering）的目标是减少那些需要通过评分查询（scoring queries）进行检查的文档。
   >
   > + 「不评分查询」，前面的查询结果其实会返回传入的 IDS 列表的对应文档结果，但是我们根本不需要，所以可以不返回 source:

3. elasticsearch是如何实现master选举的。

   > **选举的基本原则**
   >
   > 为了避免出现[Split-brain](https://en.wikipedia.org/wiki/Split-brain)现象，ES选择了分布式系统常见的quorum（多数派）思想，也就是只有获得了超过半数选票的节点才能成为master。在ES中使用 `discovery.zen.minimum_master_nodes` 属性设置quorum，这个属性一般设置为 `eligibleNodesNum / 2 + 1`。
   >
   > **如何触发一次选举**
   >
   > + 当前master eligible节点不是master
   > + 当前master eligible节点与其它的节点通信无法发现master
   > + 集群中无法连接到master的master eligible节点数量已达到 `discovery.zen.minimum_master_nodes` 所设定的值
   >
   > **如何进行选举**
   >
   > 当某个节点决定要进行一次选举是，它会实现如下操作
   >
   > 1. 寻找clusterStateVersion比自己高的master eligible的节点，向其发送选票
   > 2. 如果clusterStatrVersion一样，则计算自己能找到的master eligible节点（包括自己）中节点id最小的一个节点，向该节点发送选举投票
   > 3. 如果一个节点收到足够多的投票（即 `minimum_master_nodes` 的设置），并且它也向自己投票了，那么该节点成为master开始发布集群状态
   >
   > 下面我们用一个实际的例子来解释选举流程，假设有node_a和node_b，node_a向node_b发送选票。
   >
   > - 如果node_b已经是master，则node_b就把node_a加入集群，之后node_b发布最新的集群状态，此时node_a会被包含在最新的集群状态里面。
   > - 如果node_b正在进行选举，则node_b会把这次投票记录下来，之后node_b可能成为master或者继续等待选票。node_a等待node_b发送最新的集群状态或者超时触发下一次投票。
   > - 如果node_b认为自己不会成为master，则拒绝这次投票，node_a将触发下一次投票。

4. 详细描述一下Elasticsearch索引文档的过程。

5. 详细描述一下Elasticsearch搜索的过程。

6. Elasticsearch在部署时，对Linux的设置有哪些优化方法？

   > 把 50％ 的可用内存作为 Elasticsearch 的堆内存，保留剩下的 50％。当然它也不会被浪费，Lucene 会很乐意利用起余下的内存。
   >
   > JVM 在内存小于 32 GB 的时候会采用一个内存对象指针压缩技术。
   >
   > 对于 32 位的系统，意味着堆内存大小最大为 4 GB。对于 64 位的系统， 可以使用更大的内存，但是 64 位的指针意味着更大的浪费，因为你的指针本身大了。更糟糕的是， 更大的指针在主内存和各级缓存（例如 LLC，L1 等）之间移动数据的时候，会占用更多的带宽.
   >
   > 所以最终我们都会采用 31 G 设置
   >
   > ```shell
   > -Xms 31g
   > -Xmx 31g
   > ```

7. lucence内部结构是什么。

   > Lucence中包括了几个基础的概念，分别是索引、段、文档、域和项。其中索引由段构成，段由文档构成，因此索引可以理解为包含了多个文档的序列。文档由域构成，域由项构成，项是索引中最小构成单位，其本质是一个字符串。段是索引数据存储的基本单元，多个段之间彼此独立，当添加新的文档时将生成新的段，且段可以合并。