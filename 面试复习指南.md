# 计算机网络

1. 从输入 URL 到页面加载完成，中间发生了什么（基本必问的问题了，因为这个问题能考察对计算机网络整体的掌握程度，以及方便面试官扩展问题）/Http请求的过程与原理;

   1. DNS解析:

      1. 实现了网址到IP地址的转换;
      2. DNS解析是一个递归查询的过程;
      3. 所有网址真正的解析过程为: . -> .com -> google.com. -> www.google.com.，对应：

      本地域名服务器 -> 根域名服务器 -> com顶级域名服务器 -> google.com域名服务器 -> www.google.com的IP地址。

      	4. DNS缓存；

      DNS存在着多级缓存，从离浏览器的距离排序的话，有以下几种: 浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。

      5. DNS负载均衡，又叫做DNS重定向。

      DNS服务器会返回一个跟用户最接近的点的IP地址给用户，CDN节点的服务器负责响应用户的请求，提供所需的内容。

      ![DNS解析全过程](E:\myworkspace\Java面试复习知识点\images\1618288278-57f00bf9444dd_articlex.png)

      2. TCP连接

2. GET和POST的区别;

3. 多进程多线程浏览器（比如 Chrome），主控进程，插件进程，GPU进程，每个 tab 一个进程，tab 进程内有网络请求线程等；

4. 协议栈各层各说一些协议（记一下常用的）；

5. HTTP（基本描述，Method，协议版本及新版本特点，请求响应报文结构，常用请求头字段，常见响应状态码（每类记几个），RFC规范（知道这个词儿是啥就行了）等）；

6. 单拎出来的缓存问题，结合状态码 304 可能问到，相关头字段，If-Modified-Since 和 Last-Modified，If-None-Match 和 ETag，它们的区别等；

7. 单拎出来的 cookie 和 session 问题，搞清楚它们是干啥的，相关的头字段，其中 session 可能扩展到分布式上；

8. 单拎出来的跨域问题，了解下浏览器同源（协议，域名，端口）政策，对后端的限制（AJAX等，前端问题暂不考虑），解决方法（JSONP，WebSocket，CORS），CORS（Cross-Origin Resource Sharing）相关内容，头字段 Origin，Access-Control-Allow-Origin 等；

9. HTTPS（基本描述，主要作用，和 HTTP 的区别，SSL/TLS 握手过程，为什么过程要这样设计，对称/非对称加密，公私钥，证书，签名，CA，浏览器校验，加密算法（这个我并不懂）等）；

10. DNS（基本概念，流程，缓存，hosts 文件，DNS服务器层级，迭代/递归查询等）；

11. SOCKS（了解下这是干啥的，以及基本流程）；

12. 传输层（端到端通信服务，多路分解与多路复用，端口号的作用，套接字）；

13. TCP（必问，需要清晰掌握，简单列举一下）

    1. 基本特点，报文头大小与具体结构，序号/确认号作用，控制位及各自含义，可选头的时间戳（简单了解）；
    2. 面向连接，三握四挥（记清楚），握手的 SYN 洪泛攻击，挥手的 FIN-WAIT-2 以及 TIME-WAIT 状态，两次挥手后的 TCP 半开，四次挥手后的等待，MSL 时间，time-wait 的快速回收，fin-wait-2 的设定时间；
    3. TCP 连接能否感知对方是否在线（规范不能，实际可以），TCP 保活机制（SO_KEEPALIVE），保活参数（保活定时，失活前检查参数等），应用层面保活（心跳包，ping/pong 包等））；
    4. 可靠传输，结合序号/确认号说明，停止并等待 ARQ，结合流水线/滑动窗口的连续 ARQ，超时重传机制，RTT，RTO，差错恢复机制，GBN，SR，快速重传（冗余 ARK）等；
    5. 流量控制，目的（防止接收方缓存溢出导致分组丢失），基本原理，不足及改进（匹配相差一个 RTT，接单了解一下）；
    6. 拥塞控制，目的（避免网络拥塞），基本原理，慢启动，拥塞避免，快速回复，快速重传，AIMD（加法增大乘法减小），导致网络通讯波动（同时进入控制状态，时大时小），随机早期检测算法（了解一下）；

14. UDP（可能作为对比来问，无连接，尽力而为，面向报文，无各种控制，一对一，一对多，多对多，首部大小及结构，校验和计算过程（求和，溢出回卷，反码，校验等），可能间插着问问正反补码）；

15. TCP，UDP 伪首部，虚拟的数据结构，参与计算校验和，简单了解；

16. 网络层（主机到主机间的逻辑通信）；

17. IP （感觉其实传输层以下问的不多，能说出来就行了。v4/v6，点分十进制，各类地址空间，DNS，NAT，DHCP，路由寻址，EGP（BGP 看一下留个印象），IGP（RIP，OSPF 留个印象））；

18. ICMP（知道类型 0 和类型 8 报文是啥（Echo 响应与请求），ping 的流程）；

19. ARP（地址解析协议，了解一下流程什么的）；

20. MAC（介质访问控制协议，简单了解一下）；





# Java 基础

## 一、集合 

 集合分为两大块：java.util包下的非线程安全集合和java.util.concurrent下的线程安全集合。

### java.util包下的非线程安全集合

 List

 ArrayList与LinkedList的实现和区别

 Map
 HashMap：了解其数据结构、hash冲突如何解决（链表和红黑树）、扩容时机、扩容时避免rehash的优化

 LinkedHashMap：了解基本原理、哪两种有序、如何用它实现LRU

 TreeMap：了解数据结构、了解其key对象为什么必须要实现Compare接口、如何用它实现一致性哈希

 Set
 Set基本上都是由对应的map实现，简单看看就好

####   常见问题 

-    hashmap如何解决hash冲突，为什么hashmap中的链表需要转成红黑树？    
-    hashmap什么时候会触发扩容？    
-    jdk1.8之前并发操作hashmap时为什么会有死循环的问题？    
-    hashmap扩容时每个entry需要再计算一次hash吗？    
-    hashmap的数组长度为什么要保证是2的幂？    
-    如何用LinkedHashMap实现LRU？    
-    如何用TreeMap实现一致性hash？

### 线程安全的集合 

 Collections.synchronized
 了解其实现原理

 CopyOnWriteArrayList
 了解写时复制机制、了解其适用场景、思考为什么没有ConcurrentArrayList

 ConcurrentHashMap
 了解实现原理、扩容时做的优化、与HashTable对比。

 BlockingQueue
 了解LinkedBlockingQueue、ArrayBlockingQueue、DelayQueue、SynchronousQueue

####   常见问题 

-    ConcurrentHashMap是如何在保证并发安全的同时提高性能？    
-    ConcurrentHashMap是如何让多线程同时参与扩容？    
-    LinkedBlockingQueue、DelayQueue是如何实现的？    
-    CopyOnWriteArrayList是如何保证线程安全的？   

## 三、并发 

 synchronized
 了解偏向锁、轻量级锁、重量级锁的概念以及升级机制、以及和ReentrantLock的区别

 CAS
 了解AtomicInteger实现原理、CAS适用场景、如何实现乐观锁

 AQS
 了解AQS内部实现、及依靠AQS的同步类比如ReentrantLock、Semaphore、CountDownLatch、CyclicBarrier等的实现

 ThreadLocal
 了解ThreadLocal使用场景和内部实现

 ThreadPoolExecutor
 了解线程池的工作原理以及几个重要参数的设置

+ 线程池（具体参数，拒绝策略，减少线程的机制，具体实现类及对应的阻塞队列，阻塞队列有什么特点，为什么用这个阻塞队列，线程复用的原理）
+ 线程之间的通信方式，通过volatile，synchronized，Lock的实现类那些，结合内存模型去讲。

####  常见问题

-    synchronized与ReentrantLock的区别？    
-    乐观锁和悲观锁的区别？    
-    如何实现一个乐观锁？    
-    AQS是如何唤醒下一个线程的？    
-    ReentrantLock如何实现公平和非公平锁是如何实现？    
-    CountDownLatch和CyclicBarrier的区别？各自适用于什么场景？    
-    适用ThreadLocal时要注意什么？比如说内存泄漏?    
-    说一说往线程池里提交一个任务会发生什么？    
-    线程池的几个参数如何设置？    
-    线程池的非核心线程什么时候会被释放？    
-    如何排查死锁？   



## 四、引用 

 了解Java中的软引用、弱引用、虚引用的适用场景以及释放机制、

####   常见问题 

-    软引用什么时候会被释放    
-    弱引用什么时候会被释放   

###   



# JVM

## 一、类加载 

 了解双亲委派机制

####   常见问题 

-    双亲委派机制的作用？    
-    Tomcat的classloader结构    
-    如何自己实现一个classloader打破双亲委派   

## 二、IO 

 了解BIO和NIO的区别、了解多路复用机制

>  **BIO (Blocking I/O)**
>
> 同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。
>
> + **传统 BIO**: 一请求一应答
>
>   采用 **BIO 通信模型** 的服务端，通常由一个独立的 Acceptor 线程负责监听客户端的连接。我们一般通过在`while(true)` 循环中服务端会调用 `accept()` 方法等待接收客户端的连接的方式监听请求，请求一旦接收到一个连接请求，就可以建立通信套接字在这个通信套接字上进行读写操作，此时不能再接收其他客户端连接请求，只能等待同当前连接的客户端的操作执行完成， 不过可以通过多线程来支持多个客户端的连接.
>
>   **当客户端并发访问量增加后这种模型会出现什么问题？**
>
>   在 Java 虚拟机中，线程是宝贵的资源，线程的创建和销毁成本很高，除此之外，线程的切换成本也是很高的。尤其在 Linux 这样的操作系统中，线程本质上就是一个进程，创建和销毁线程都是重量级的系统函数。如果并发访问量增加会导致线程数急剧膨胀可能会导致线程堆栈溢出、创建新线程失败等问题，最终导致进程宕机或者僵死，不能对外提供服务
>
> + **伪异步 IO**
>
>   后端通过一个线程池来处理多个客户端的请求接入，形成客户端个数M：线程池最大线程数N的比例关系，其中M可以远远大于N.通过线程池可以灵活地调配线程资源，设置线程的最大值，防止由于海量并发接入导致线程耗尽。
>
>   伪异步I/O通信框架采用了线程池实现，因此避免了为每个请求都创建一个独立线程造成的线程资源耗尽问题。不过因为它的底层仍然是同步阻塞的BIO模型，因此无法从根本上解决问题。

 常见问题

- 同步阻塞、同步非阻塞、异步的区别？

  > **同步与异步**
  >
  > - **同步：** 同步就是发起一个调用后，被调用者未处理完请求之前，调用不返回。
  > - **异步：** 异步就是发起一个调用后，立刻得到被调用者的回应表示已接收到请求，但是被调用者并没有返回结果，此时我们可以处理其他的请求，被调用者通常依靠事件，回调等机制来通知调用者其返回结果。
  >
  > 同步和异步的区别最大在于异步的话调用者不需要等待处理结果，被调用者会通过回调等机制来通知调用者其返回结果。
  >
  > **阻塞和非阻塞**
  >
  > - **阻塞：** 阻塞就是发起一个请求，调用者一直等待请求结果返回，也就是当前线程会被挂起，无法从事其他任务，只有当条件就绪才能继续。
  > - **非阻塞：** 非阻塞就是发起一个请求，调用者不用一直等着结果返回，可以先去干其他事情。
  >
  > 举个生活中简单的例子，你妈妈让你烧水，小时候你比较笨啊，在那里傻等着水开（**同步阻塞**）。等你稍微再长大一点，你知道每次烧水的空隙可以去干点其他事，然后只需要时不时来看看水开了没有（**同步非阻塞**）。后来，你们家用上了水开了会发出声音的壶，这样你就只需要听到响声后就知道水开了，在这期间你可以随便干自己的事情，你需要去倒水了（**异步非阻塞**）。
  >
  > 

  

- select、poll、eopll的区别？ 

  > 

- java NIO与BIO的区别？   

  >  **NIO的特性/NIO与IO区别**
  >
  > 如果是在面试中回答这个问题，我觉得首先肯定要从 NIO 流是非阻塞 IO 而 IO 流是阻塞 IO 说起。然后，可以从 NIO 的3个核心组件/特性为 NIO 带来的一些改进来分析。

  > + **1)Non-blocking IO（非阻塞IO）**
  >
  > **IO流是阻塞的，NIO流是不阻塞的。**
  >
  > Java NIO使我们可以进行非阻塞IO操作。比如说，单线程中从通道读取数据到buffer，同时可以继续做别的事情，当数据读取到buffer中后，线程再继续处理数据。写数据也是一样的。另外，非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。
  >
  > Java IO的各种流是阻塞的。这意味着，当一个线程调用 `read()` 或 `write()` 时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了
  >
  > + **2)Buffer(缓冲区)**
  >
  > **IO 面向流(Stream oriented)，而 NIO 面向缓冲区(Buffer oriented)。**
  >
  > Buffer是一个对象，它包含一些要写入或者要读出的数据。在NIO类库中加入Buffer对象，体现了新库与原I/O的一个重要区别。在面向流的I/O中·可以将数据直接写入或者将数据直接读到 Stream 对象中。虽然 Stream 中也有 Buffer 开头的扩展类，但只是流的包装类，还是从流读到缓冲区，而 NIO 却是直接读到 Buffer 中进行操作。
  >
  > 在NIO厍中，所有数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区中的; 在写入数据时，写入到缓冲区中。任何时候访问NIO中的数据，都是通过缓冲区进行操作。
  >
  > 最常用的缓冲区是 ByteBuffer,一个 ByteBuffer 提供了一组功能用于操作 byte 数组。除了ByteBuffer,还有其他的一些缓冲区，事实上，每一种Java基本类型（除了Boolean类型）都对应有一种缓冲区。
  >
  > + **3)Channel (通道)**
  >
  > NIO 通过Channel（通道） 进行读写。
  >
  > 通道是双向的，可读也可写，而流的读写是单向的。无论读写，通道只能和Buffer交互。因为 Buffer，通道可以异步地读写。
  >
  > **4)Selector (选择器)**
  >
  > NIO有选择器，而IO没有。
  >
  > 选择器用于使用单个线程处理多个通道。因此，它需要较少的线程来处理这些通道。线程之间的切换对于操作系统来说是昂贵的。 因此，为了提高系统效率选择器是有用的。

- reactor线程模型是什么?

##  三、GC

垃圾回收基本原理、几种常见的垃圾回收器的特性、重点了解CMS（或G1）以及一些重要的参数

+ 内存区域：能说清jvm的内存划分

+ 对象是否可回收的判断条件，怎么判断，回收算法，垃圾回收器的类别及特点，担保机制

####   常见问题 

-    CMS GC回收分为哪几个阶段？分别做了什么事情？    
-    CMS有哪些重要参数？    
-    Concurrent Model Failure和ParNew promotion failed什么情况下会发生？    
-    CMS的优缺点？    
-    有做过哪些GC调优？    
-    为什么要划分成年轻代和老年代？    
-    年轻代为什么被划分成eden、survivor区域？    
-    年轻代为什么采用的是复制算法？    
-    老年代为什么采用的是标记清除、标记整理算法    
-    什么情况下使用堆外内存？要注意些什么？    
-    堆外内存如何被回收？    
-    jvm内存区域划分是怎样的？   

# 中间件、存储6、以及其他框架 

## 一、spring 

Spring：bean的生命周期、循环依赖问题、spring cloud（如项目中有用过）、AOP的实现、spring事务传播

####   常见问题 

-    java动态***和cglib动态***的区别（经常结合spring一起问所以就放这里了）    
-    spring中bean的生命周期是怎样的？    
-    属性注入和构造器注入哪种会有循环依赖的问题？   



 ## 二、Dubbo（或其他Rpc框架）
 了解一个常用RPC框架如Dubbo的实现：服务发现、路由、异步调用、限流降级、失败重试

####   常见问题 

-    Dubbo如何做负载均衡？    
-    Dubbo如何做限流降级？    
-    Dubbo如何优雅的下线服务？    
-    Dubbo如何实现异步调用的？   



 ## 三、RocketMq（或其他消息中间件）
 了解一个常用消息中间件如RocketMq的实现：如何保证高可用和高吞吐、消息顺序、重复消费、事务消息、延迟消息、死信队列

####   常见问题 

-    RocketMq如何保证高可用的？    
-    RocketMq如何保证高吞吐的？    
-    RocketMq的消息是有序的吗？    
-    RocketMq的消息局部顺序是如何保证的?    
-    RocketMq事务消息的实现机制？    
-    RocketMq会有重复消费的问题吗？如何解决？    
-    RocketMq支持什么级别的延迟消息？如何实现的？    
-    RocketMq是推模型还是拉模型？    
-    Consumer的负载均衡是怎么样的？   

###   

## 四、Redis（或其他缓存系统） 

 redis工作模型、redis持久化、redis过期淘汰机制、redis分布式集群的常见形式、分布式锁、缓存击穿、缓存雪崩、缓存一致性问题

####   常见问题 

-    redis性能为什么高?    
-    单线程的redis如何利用多核cpu机器？    
-    redis的缓存淘汰策略？    
-    redis如何持久化数据？    
-    redis有哪几种数据结构？    
-    redis集群有哪几种形式？    
-    有海量key和value都比较小的数据，在redis中如何存储才更省内存？    
-    如何保证redis和DB中的数据一致性？    
-    如何解决缓存穿透和缓存雪崩？    
-    如何用redis实现分布式锁？   

## 五、Mysql 

 事务隔离级别、锁、索引的数据结构、聚簇索引和非聚簇索引、最左匹配原则、查询优化（explain等命令）

####   常见问题 

-    Mysql(innondb 下同) 有哪几种事务隔离级别？    
-    不同事务隔离级别分别会加哪些锁？    
-    mysql的行锁、表锁、间隙锁、意向锁分别是做什么的？    
-    说说什么是最左匹配？    
-    如何优化慢查询？    
-    mysql索引为什么用的是b+ tree而不是b tree、红黑树    
-    分库分表如何选择分表键    
-    分库分表的情况下，查询时一般是如何做排序的？   

## 五、zk 

 zk大致原理（可以了解下原理相近的Raft算法）、zk实现分布式锁、zk做集群master选举

####   常见问题 

-    如何用zk实现分布式锁，与redis分布式锁有和优缺点    
-    HBase（如简历有写）    
-    HBase适用的场景、架构、merge和split、查写数据的流程。   

###   Storm（如简历有写） 

 Storm与Map Reduce、Spark、Flink的比较。Storm高可用、消息ack机制

# 算法 

 算法的话不是所有公司都会问，但最好还是准备下，主要是靠刷题，在leetcode上刷个100-200道easy和medium的题，然后对应公司的面经多看看，问题应该不大。